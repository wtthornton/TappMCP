<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ TappMCP D3.js Enhanced - Modular ES6</title>

    <!-- Modern ES Module Structure -->
    <script type="module">
        async function loadD3() {
            try {
                // Import D3.js as a complete module for better compatibility
                const d3 = await import('https://cdn.jsdelivr.net/npm/d3@7/+esm');

                // Make D3 functions globally available for the rest of the application
                window.d3 = d3;

                console.log('‚úÖ D3.js v7+ ES modules loaded successfully!');
                console.log('üì¶ Bundle size optimized with selective imports');

                // Signal that D3 is ready
                window.d3Ready = true;
                window.dispatchEvent(new CustomEvent('d3Ready'));
            } catch (error) {
                console.error('‚ùå D3.js ES module import failed:', error);
                console.log('üîÑ Falling back to script tag method...');

                // Fallback: Load D3.js via script tag
                const script = document.createElement('script');
                script.src = 'https://d3js.org/d3.v7.min.js';
                script.onload = () => {
                    window.d3 = d3;
                    window.d3Ready = true;
                    window.dispatchEvent(new CustomEvent('d3Ready'));
                    console.log('‚úÖ D3.js loaded via fallback method');
                };
                script.onerror = () => {
                    console.error('‚ùå D3.js fallback also failed');
                };
                document.head.appendChild(script);
            }
        }

        // Load D3.js
        loadD3();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --accent-bg: #2a2a2a;
            --primary-text: #ffffff;
            --secondary-text: #b0b0b0;
            --accent-color: #00ff88;
            --error-color: #ff4444;
            --warning-color: #ffaa00;
            --info-color: #4facfe;
            --success-color: #00ff88;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            color: var(--primary-text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .header {
            background: var(--secondary-bg);
            padding: 20px;
            border-bottom: 1px solid var(--accent-bg);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-color), var(--info-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: var(--secondary-text);
            font-size: 1.1rem;
        }

        .nav-links {
            display: flex;
            gap: 16px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .nav-link {
            padding: 8px 16px;
            background: var(--accent-bg);
            color: var(--primary-text);
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-link:hover {
            background: var(--accent-color);
            color: var(--primary-bg);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }

        .nav-link.active {
            background: var(--accent-color);
            color: var(--primary-bg);
        }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--accent-bg);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .status-item:hover {
            background: var(--secondary-bg);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-color);
            box-shadow: 0 0 10px var(--accent-color);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: var(--error-color);
            box-shadow: 0 0 10px var(--error-color);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .visualization-section {
            margin: 20px;
            padding: 20px;
            background: var(--secondary-bg);
            border-radius: 12px;
            border: 1px solid var(--accent-bg);
            transition: all 0.3s ease;
        }

        .visualization-section:hover {
            border-color: var(--accent-color);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.1);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 16px;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-container {
            width: 100%;
            height: 400px;
            border: 1px solid var(--accent-bg);
            border-radius: 8px;
            overflow: hidden;
            background: var(--primary-bg);
            position: relative;
        }

        .chart-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 16px;
            background: var(--accent-color);
            color: var(--primary-bg);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn:hover {
            background: #00cc6a;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.secondary {
            background: var(--info-color);
        }

        .btn.secondary:hover {
            background: #3b82f6;
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3);
        }

        .loading {
            text-align: center;
            color: var(--secondary-text);
            padding: 40px;
            font-size: 1.1rem;
        }

        .error {
            text-align: center;
            color: var(--error-color);
            padding: 40px;
            font-size: 1.1rem;
        }

        .success {
            text-align: center;
            color: var(--success-color);
            padding: 40px;
            font-size: 1.1rem;
        }

        /* Enhanced D3.js Chart Styles */
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            fill: var(--accent-color);
            stroke: var(--primary-bg);
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node circle:hover {
            fill: #00cc6a;
            stroke: var(--primary-text);
            stroke-width: 3px;
            transform: scale(1.2);
        }

        .node text {
            fill: var(--primary-text);
            font-size: 12px;
            text-anchor: middle;
            font-weight: 500;
        }

        .link {
            fill: none;
            stroke: var(--secondary-text);
            stroke-width: 2px;
            stroke-opacity: 0.6;
            transition: all 0.3s ease;
        }

        .link:hover {
            stroke: var(--accent-color);
            stroke-width: 3px;
            stroke-opacity: 1;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: var(--accent-color);
            stroke: var(--primary-text);
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node text {
            fill: var(--primary-text);
            font-size: 12px;
            font-weight: 500;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-active circle {
            fill: #10b981;
            stroke: #059669;
            stroke-width: 3px;
        }

        .node-pending circle {
            fill: #f59e0b;
            stroke: #d97706;
        }

        .node-completed circle {
            fill: #3b82f6;
            stroke: #2563eb;
        }

        .node-error circle {
            fill: #ef4444;
            stroke: #dc2626;
        }

        .node:hover circle {
            stroke-width: 4px;
            transform: scale(1.1);
        }

        .bar {
            fill: var(--accent-color);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .bar:hover {
            fill: #00cc6a;
            stroke: var(--primary-text);
            stroke-width: 2px;
            transform: scale(1.05);
            transform-origin: bottom;
        }

        .line {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 3px;
            transition: all 0.3s ease;
        }

        .line:hover {
            stroke: #00cc6a;
            stroke-width: 4px;
        }

        .area {
            fill: var(--accent-color);
            fill-opacity: 0.3;
            transition: all 0.3s ease;
        }

        .axis {
            color: var(--secondary-text);
        }

        .axis text {
            fill: var(--secondary-text);
            font-size: 11px;
        }

        .axis path,
        .axis line {
            stroke: var(--secondary-text);
        }

        .grid-line {
            stroke: var(--accent-bg);
            stroke-opacity: 0.3;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: var(--secondary-bg);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            max-width: 250px;
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip-content {
            color: var(--primary-text);
            font-size: 12px;
            line-height: 1.4;
        }

        /* Performance Metrics */
        .performance-metrics {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--accent-bg);
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            color: var(--secondary-text);
            z-index: 1000;
            opacity: 0.7;
        }

        .performance-metrics:hover {
            opacity: 1;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .chart-container {
                height: 300px;
            }

            .chart-controls {
                justify-content: center;
            }

            .btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .status-bar {
                justify-content: center;
            }
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--accent-bg);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--secondary-bg);
            margin: 5% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            border: 1px solid var(--accent-bg);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--accent-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: var(--accent-color);
        }

        .close {
            color: var(--secondary-text);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: var(--error-color);
        }

        .modal-body {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-text);
            font-weight: 500;
        }

        .setting-group input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .setting-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .setting-group span {
            color: var(--accent-color);
            font-weight: 600;
        }

        .setting-group h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
        }

        #streamingMetrics div {
            margin: 5px 0;
            padding: 5px;
            background: var(--accent-bg);
            border-radius: 4px;
        }

        /* Interactive Navigation Styles */
        .brush {
            fill: var(--accent-color);
            fill-opacity: 0.2;
            stroke: var(--accent-color);
            stroke-width: 2px;
        }

        .brush-handle {
            fill: var(--accent-color);
            stroke: var(--primary-bg);
            stroke-width: 2px;
            cursor: ew-resize;
        }

        .zoom-rect {
            fill: var(--info-color);
            fill-opacity: 0.1;
            stroke: var(--info-color);
            stroke-width: 2px;
            stroke-dasharray: 5,5;
        }

        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--accent-bg);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: var(--primary-text);
            pointer-events: none;
            z-index: 100;
        }

        .navigation-help {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--accent-bg);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            color: var(--secondary-text);
            pointer-events: none;
            z-index: 100;
        }

        .chart-container {
            position: relative;
        }

        /* Touch gesture indicators */
        .touch-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .touch-indicator.active {
            opacity: 0.6;
        }

        /* Selection overlay */
        .selection-overlay {
            fill: var(--accent-color);
            fill-opacity: 0.1;
            stroke: var(--accent-color);
            stroke-width: 2px;
            stroke-dasharray: 3,3;
            pointer-events: none;
        }

        /* Selected elements */
        .node.selected circle {
            stroke: var(--info-color) !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 8px var(--info-color));
        }

        .bar.selected {
            fill: var(--info-color) !important;
            filter: drop-shadow(0 0 8px var(--info-color));
        }

        .line.selected {
            stroke: var(--info-color) !important;
            stroke-width: 5px !important;
            filter: drop-shadow(0 0 8px var(--info-color));
        }

        /* Touch gesture styles */
        .touch-active {
            cursor: grabbing !important;
        }

        .chart-container.touch-active {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Mobile touch indicators */
        @media (max-width: 768px) {
            .navigation-help {
                font-size: 10px;
                padding: 6px 10px;
            }

            .zoom-indicator {
                font-size: 10px;
                padding: 4px 8px;
            }
        }

        /* Performance optimization styles */
        .virtual-item {
            transition: all 0.2s ease;
            will-change: transform;
        }

        .performance-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            background: var(--accent-bg);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: var(--primary-text);
            pointer-events: none;
            z-index: 100;
        }

        .cache-hit {
            color: var(--success-color);
        }

        .cache-miss {
            color: var(--warning-color);
        }

        .memory-warning {
            color: var(--error-color);
            animation: pulse 1s infinite;
        }

        /* Optimized rendering styles */
        .chart-container {
            contain: layout style paint;
            will-change: transform;
        }

        .optimized-render {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Performance metrics display */
        .performance-overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--secondary-bg);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--accent-bg);
            font-size: 12px;
            color: var(--primary-text);
            z-index: 1000;
            min-width: 200px;
        }

        .performance-overlay.hidden {
            display: none;
        }

        .performance-overlay h4 {
            margin: 0 0 8px 0;
            color: var(--accent-color);
            font-size: 14px;
        }

        .performance-metric {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 2px 0;
            border-bottom: 1px solid var(--accent-bg);
        }

        .performance-metric:last-child {
            border-bottom: none;
        }

        .performance-value {
            font-weight: 600;
            color: var(--accent-color);
        }

        .performance-value.warning {
            color: var(--warning-color);
        }

        .performance-value.error {
            color: var(--error-color);
        }

        /* Essential Chart Types Styles */
        #chartTypeSelect {
            background: var(--secondary-bg);
            color: var(--primary-text);
            border: 1px solid var(--accent-bg);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            margin-right: 10px;
        }

        #chartTypeSelect:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .gauge-chart {
            text-align: center;
        }

        .gauge-value {
            font-size: 2.5rem;
            font-weight: bold;
            fill: var(--accent-color);
        }

        .gauge-label {
            font-size: 1.2rem;
            fill: var(--secondary-text);
        }

        .line-chart .line {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 3px;
        }

        .area-chart .area {
            fill: url(#areaGradient);
            opacity: 0.7;
        }

        .area-chart .line {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 2px;
        }

        .chart-point {
            fill: var(--accent-color);
            stroke: var(--primary-bg);
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-point:hover {
            fill: var(--info-color);
            stroke-width: 3px;
            r: 6;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ TappMCP D3.js Enhanced - Modular ES6</h1>
        <p>Advanced data visualizations with modern ES6 modules and optimized performance</p>

        <div class="nav-links">
            <a href="index.html" class="nav-link">üìä Main Dashboard</a>
            <a href="d3-enhanced-modular.html" class="nav-link active">üöÄ Enhanced D3.js</a>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Connecting...</span>
            </div>
            <div class="status-item">
                <span>Last updated: <strong id="lastUpdate">Never</strong></span>
            </div>
            <div class="status-item">
                <span>D3.js Version: <strong>v7+ (ES Modules)</strong></span>
            </div>
            <div class="status-item">
                <span>Bundle Size: <strong id="bundleSize">Optimized</strong></span>
            </div>
        </div>
    </div>

    <!-- Performance Metrics -->
    <div class="performance-metrics" id="performanceMetrics">
        <div>Render Time: <span id="renderTime">-</span>ms</div>
        <div>Memory: <span id="memoryUsage">-</span>MB</div>
        <div>FPS: <span id="fps">-</span></div>
    </div>

    <!-- Performance Overlay -->
    <div class="performance-overlay" id="performanceOverlay">
        <h4>üöÄ Performance Monitor</h4>
        <div class="performance-metric">
            <span>Render Time:</span>
            <span class="performance-value" id="overlayRenderTime">-</span>
        </div>
        <div class="performance-metric">
            <span>Memory Usage:</span>
            <span class="performance-value" id="overlayMemoryUsage">-</span>
        </div>
        <div class="performance-metric">
            <span>Frame Rate:</span>
            <span class="performance-value" id="overlayFPS">-</span>
        </div>
        <div class="performance-metric">
            <span>Cache Hit Rate:</span>
            <span class="performance-value" id="overlayCacheHitRate">-</span>
        </div>
        <div class="performance-metric">
            <span>Render Queue:</span>
            <span class="performance-value" id="overlayRenderQueue">-</span>
        </div>
        <button class="btn secondary" onclick="togglePerformanceOverlay()" style="width: 100%; margin-top: 8px;">
            Toggle Details
        </button>
    </div>

        <!-- Enhanced Workflow Graph -->
    <div class="visualization-section">
        <h2 class="section-title">
            üîó Enhanced Interactive Workflow Graph
            <span class="loading-spinner" id="workflowLoading" style="display: none;"></span>
        </h2>
        <div class="chart-controls">
            <button class="btn" onclick="workflowChart.restart()">üîÑ Restart</button>
            <button class="btn" onclick="workflowChart.addRandomNode()">‚ûï Add Node</button>
            <button class="btn secondary" onclick="workflowChart.toggleAnimation()">üé¨ Toggle Animation</button>
            <button class="btn secondary" onclick="workflowChart.toggleZoom()">üîç Toggle Zoom</button>
            <button class="btn secondary" onclick="workflowChart.resetView()">üè† Reset View</button>
            <button class="btn secondary" onclick="workflowChart.exportSVG()">üì§ Export SVG</button>
        </div>
        <div class="chart-container" id="workflow-graph"></div>
    </div>

    <!-- Enhanced Performance Chart -->
    <div class="visualization-section">
        <h2 class="section-title">
            üìä Enhanced Performance Metrics
            <span class="loading-spinner" id="performanceLoading" style="display: none;"></span>
        </h2>
        <div class="chart-controls">
            <button class="btn" onclick="performanceChart.updateData()">üîÑ Update</button>
            <button class="btn" onclick="performanceChart.toggleChartType()">üìà Toggle Type</button>
            <button class="btn secondary" onclick="performanceChart.toggleZoom()">üîç Toggle Zoom</button>
            <button class="btn secondary" onclick="performanceChart.toggleBrush()">üñåÔ∏è Toggle Brush</button>
            <button class="btn secondary" onclick="performanceChart.resetView()">üè† Reset View</button>
            <button class="btn secondary" onclick="performanceChart.exportChart()">üì§ Export</button>
        </div>
        <div class="chart-container" id="performance-chart"></div>
    </div>

    <!-- Real-time Line Chart -->
    <div class="visualization-section">
        <h2 class="section-title">
            üìà Real-time Line Chart
            <span class="loading-spinner" id="lineChartLoading" style="display: none;"></span>
        </h2>
        <div class="chart-controls">
            <button class="btn" onclick="startRealTimeStreaming()">‚ñ∂Ô∏è Start Streaming</button>
            <button class="btn" onclick="stopRealTimeStreaming()">‚è∏Ô∏è Stop Streaming</button>
            <button class="btn secondary" onclick="lineChart.toggleZoom()">üîç Toggle Zoom</button>
            <button class="btn secondary" onclick="lineChart.toggleBrush()">üñåÔ∏è Toggle Brush</button>
            <button class="btn secondary" onclick="clearStreamingData()">üóëÔ∏è Clear Data</button>
            <button class="btn secondary" onclick="exportStreamingData()">üíæ Export Data</button>
            <button class="btn secondary" onclick="showStreamingSettings()">‚öôÔ∏è Settings</button>
        </div>
        <div class="chart-container" id="line-chart"></div>
    </div>

    <!-- Essential Chart Types -->
    <div class="visualization-section">
        <h2 class="section-title">
            üìä Essential Chart Types
            <span class="loading-spinner" id="essentialChartsLoading" style="display: none;"></span>
        </h2>
        <div class="chart-controls">
            <select id="chartTypeSelect" onchange="switchChartType(this.value)">
                <option value="line">üìà Line Chart</option>
                <option value="area">üìä Area Chart</option>
                <option value="gauge">‚è±Ô∏è Gauge Chart</option>
            </select>
            <button class="btn" onclick="updateChartData()">üîÑ Update Data</button>
            <button class="btn secondary" onclick="exportCurrentChart()">üì§ Export SVG</button>
            <button class="btn secondary" onclick="exportChartAsCSV()">üìä Export CSV</button>
            <button class="btn secondary" onclick="toggleChartAnimation()">üé¨ Toggle Animation</button>
        </div>
        <div class="chart-container" id="essential-charts"></div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-content" id="tooltipContent"></div>
    </div>

    <!-- Streaming Settings Modal -->
    <div id="streamingSettingsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚öôÔ∏è Real-time Streaming Settings</h3>
                <span class="close" onclick="closeStreamingSettings()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="setting-group">
                    <label>Buffer Size:</label>
                    <input type="range" id="bufferSize" min="100" max="5000" value="1000" onchange="updateStreamingSetting('maxBufferSize', this.value)">
                    <span id="bufferSizeValue">1000</span>
                </div>
                <div class="setting-group">
                    <label>Update Frequency (ms):</label>
                    <input type="range" id="updateFrequency" min="50" max="1000" value="100" onchange="updateStreamingSetting('updateFrequency', this.value)">
                    <span id="updateFrequencyValue">100</span>
                </div>
                <div class="setting-group">
                    <label>
                        <input type="checkbox" id="compressionEnabled" checked onchange="updateStreamingSetting('compressionEnabled', this.checked)">
                        Enable Data Compression
                    </label>
                </div>
                <div class="setting-group">
                    <label>
                        <input type="checkbox" id="autoReconnect" checked onchange="updateStreamingSetting('autoReconnect', this.checked)">
                        Auto-reconnect on Disconnect
                    </label>
                </div>
                <div class="setting-group">
                    <h4>Performance Metrics:</h4>
                    <div id="streamingMetrics">
                        <div>Updates/sec: <span id="updatesPerSecond">0</span></div>
                        <div>Avg Latency: <span id="averageLatency">0</span>ms</div>
                        <div>Data Loss Rate: <span id="dataLossRate">0</span>%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Enhanced D3.js Dashboard with ES Modules
        class EnhancedD3Dashboard {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.performanceMonitor = new PerformanceMonitor();
                this.dataStream = new RealTimeDataStream();

                // Performance optimization properties
                this.cache = new Map();
                this.cacheTimeout = 30000; // 30 seconds
                this.renderQueue = [];
                this.isRendering = false;
                this.frameRate = 60;
                this.lastRenderTime = 0;
                this.memoryThreshold = 100 * 1024 * 1024; // 100MB
                this.lazyLoadThreshold = 1000; // Lazy load datasets > 1000 items
                this.virtualizationEnabled = true;
                this.debounceTimers = new Map();
                this.performanceMetrics = {
                    renderCount: 0,
                    averageRenderTime: 0,
                    memoryUsage: 0,
                    cacheHitRate: 0,
                    frameRate: 0
                };

                console.log('üöÄ Initializing Enhanced D3 Dashboard with Performance Optimization...');
                this.init();
            }

            init() {
                this.performanceMonitor.start();
                this.setupPerformanceMonitoring();
                this.setupMemoryManagement();
                this.connectWebSocket();
                this.initializeCharts();
                this.setupEventListeners();

                // Setup visibility change handling
                document.addEventListener('visibilitychange', () => {
                    this.handleVisibilityChange();
                });
            }

            connectWebSocket() {
                console.log('üîå Connecting to WebSocket...');

                try {
                    this.ws = new WebSocket('ws://localhost:3000');

                    this.ws.onopen = () => {
                        console.log('‚úÖ WebSocket connected!');
                        this.updateConnectionStatus(true);
                        this.reconnectAttempts = 0;
                        this.dataStream.setWebSocket(this.ws);
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (error) {
                            console.error('‚ùå Message parse error:', error);
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('‚ùå WebSocket disconnected. Code:', event.code);
                        this.updateConnectionStatus(false);
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('‚ùå WebSocket error:', error);
                        this.updateConnectionStatus(false);
                    };

                } catch (error) {
                    console.error('‚ùå WebSocket connection failed:', error);
                    this.updateConnectionStatus(false);
                    this.scheduleReconnect();
                }
            }

            handleMessage(data) {
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();

                // Send data to real-time stream handler
                this.dataStream.handleRealTimeUpdate(data);

                switch (data.type) {
                    case 'performance_metrics':
                        if (window.performanceChart) {
                            window.performanceChart.updateWithData(data.data);
                        }
                        if (window.lineChart) {
                            window.lineChart.addDataPoint(data.data);
                        }
                        break;
                    case 'workflow_status_update':
                        if (window.workflowChart) {
                            window.workflowChart.updateWithData(data.data);
                        }
                        break;
                }
            }

            updateConnectionStatus(connected) {
                const statusDot = document.getElementById('connectionStatus');
                const statusText = document.getElementById('connectionText');

                if (connected) {
                    statusDot.classList.remove('disconnected');
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.classList.add('disconnected');
                    statusText.textContent = 'Disconnected';
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

                    console.log(`üîÑ Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connectWebSocket(), delay);
                }
            }

            initializeCharts() {
                console.log('üöÄ Initializing charts...');

                // Check if D3 is available
                if (typeof d3 === 'undefined') {
                    console.error('‚ùå D3.js not loaded!');
                    return;
                }
                console.log('‚úÖ D3.js is available');

                // Check if container exists
                const workflowContainer = document.querySelector('#workflow-graph');
                if (!workflowContainer) {
                    console.error('‚ùå Workflow graph container not found!');
                    return;
                }
                console.log('‚úÖ Workflow graph container found');

                // Initialize enhanced charts
                window.workflowChart = new EnhancedWorkflowChart('#workflow-graph');
                window.performanceChart = new EnhancedPerformanceChart('#performance-chart');
                window.lineChart = new RealTimeLineChart('#line-chart');

                console.log('‚úÖ All charts initialized');

                // Subscribe charts to real-time data stream
                this.setupChartSubscriptions();
            }

            setupChartSubscriptions() {
                // Subscribe performance chart to real-time updates
                if (this.dataStream && window.performanceChart) {
                    this.dataStream.subscribe((data) => {
                        if (data.type === 'performance_metrics' || data.cpuUsage !== undefined) {
                            window.performanceChart.updateWithRealTimeData(data);
                        }
                    });
                }

                // Subscribe line chart to real-time updates
                if (this.dataStream && window.lineChart) {
                    this.dataStream.subscribe((data) => {
                        if (data.type === 'performance_metrics' || data.cpuUsage !== undefined) {
                            window.lineChart.addRealTimeDataPoint(data);
                        }
                    });
                }

                // Subscribe workflow chart to real-time updates
                if (this.dataStream && window.workflowChart) {
                    this.dataStream.subscribe((data) => {
                        if (data.type === 'workflow_status_update') {
                            window.workflowChart.updateWithRealTimeData(data);
                        }
                    });
                }

                // Listen for streaming control events
                if (this.dataStream) {
                    this.dataStream.subscribe((data) => {
                        if (data.type === 'streaming_started') {
                            document.getElementById('lineChartLoading').style.display = 'inline-block';
                        } else if (data.type === 'streaming_stopped') {
                            document.getElementById('lineChartLoading').style.display = 'none';
                        }
                    });
                }
            }

            setupEventListeners() {
                // Global event listeners
                window.addEventListener('resize', () => {
                    this.handleResize();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (event) => {
                    this.handleKeyboard(event);
                });
            }

            handleResize() {
                // Handle window resize
                if (window.workflowChart) window.workflowChart.resize();
                if (window.performanceChart) window.performanceChart.resize();
                if (window.lineChart) window.lineChart.resize();
            }

            handleKeyboard(event) {
                if (event.ctrlKey) {
                    switch(event.key) {
                        case 'r':
                            event.preventDefault();
                            this.restartAllCharts();
                            break;
                        case 'z':
                            event.preventDefault();
                            this.resetAllZoom();
                            break;
                    }
                }
            }

            restartAllCharts() {
                console.log('üîÑ Restarting all charts...');
                if (window.workflowChart) window.workflowChart.restart();
                if (window.performanceChart) window.performanceChart.updateData();
                if (window.lineChart) window.lineChart.restart();
            }

            resetAllZoom() {
                console.log('üè† Resetting all zoom levels...');
                if (window.performanceChart) window.performanceChart.resetZoom();
                if (window.lineChart) window.lineChart.resetZoom();
            }

            // Performance optimization methods
            debounce(func, delay) {
                const key = func.toString();
                if (this.debounceTimers.has(key)) {
                    clearTimeout(this.debounceTimers.get(key));
                }

                const timer = setTimeout(() => {
                    func();
                    this.debounceTimers.delete(key);
                }, delay);

                this.debounceTimers.set(key, timer);
                return () => {
                    clearTimeout(timer);
                    this.debounceTimers.delete(key);
                };
            }

            setupPerformanceMonitoring() {
                // Monitor frame rate
                let lastTime = performance.now();
                let frameCount = 0;

                const measureFrameRate = () => {
                    const currentTime = performance.now();
                    frameCount++;

                    if (currentTime - lastTime >= 1000) {
                        this.performanceMetrics.frameRate = Math.round((frameCount * 1000) / (currentTime - lastTime));
                        frameCount = 0;
                        lastTime = currentTime;
                        this.updatePerformanceDisplay();
                    }

                    requestAnimationFrame(measureFrameRate);
                };

                requestAnimationFrame(measureFrameRate);
            }

            setupMemoryManagement() {
                // Monitor memory usage
                setInterval(() => {
                    if (performance.memory) {
                        this.performanceMetrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);

                        // Trigger garbage collection if memory usage is high
                        if (this.performanceMetrics.memoryUsage > 80) {
                            this.triggerGarbageCollection();
                        }
                    }
                }, 5000);
            }

            triggerGarbageCollection() {
                console.log('üóëÔ∏è Triggering garbage collection...');

                // Clear expired cache entries
                this.clearExpiredCache();

                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                }

                // Clear unused event listeners
                this.cleanupUnusedListeners();
            }

            clearExpiredCache() {
                const now = Date.now();
                for (const [key, value] of this.cache.entries()) {
                    if (now - value.timestamp > this.cacheTimeout) {
                        this.cache.delete(key);
                    }
                }
            }

            cleanupUnusedListeners() {
                // Clean up unused debounce timers
                for (const [key, timer] of this.debounceTimers.entries()) {
                    if (Date.now() - timer.timestamp > 60000) { // 1 minute
                        clearTimeout(timer);
                        this.debounceTimers.delete(key);
                    }
                }
            }

            handleVisibilityChange() {
                if (document.hidden) {
                    // Page is hidden, reduce performance overhead
                    this.pausePerformanceIntensiveOperations();
                } else {
                    // Page is visible, resume operations
                    this.resumePerformanceIntensiveOperations();
                }
            }

            pausePerformanceIntensiveOperations() {
                console.log('‚è∏Ô∏è Pausing performance-intensive operations');
                // Pause real-time updates
                if (this.dataStream) {
                    this.dataStream.stopStreaming();
                }
            }

            resumePerformanceIntensiveOperations() {
                console.log('‚ñ∂Ô∏è Resuming performance-intensive operations');
                // Resume real-time updates
                if (this.dataStream) {
                    this.dataStream.startStreaming();
                }
            }

            // Caching system
            getCachedData(key) {
                const cached = this.cache.get(key);
                if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
                    this.performanceMetrics.cacheHitRate = (this.performanceMetrics.cacheHitRate + 1) / 2;
                    return cached.data;
                }
                return null;
            }

            setCachedData(key, data) {
                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });

                // Limit cache size
                if (this.cache.size > 100) {
                    const oldestKey = this.cache.keys().next().value;
                    this.cache.delete(oldestKey);
                }
            }

            // Rendering optimization
            queueRender(renderFunction, priority = 0) {
                this.renderQueue.push({ renderFunction, priority });
                this.renderQueue.sort((a, b) => b.priority - a.priority);

                if (!this.isRendering) {
                    this.processRenderQueue();
                }
            }

            async processRenderQueue() {
                this.isRendering = true;
                const startTime = performance.now();

                while (this.renderQueue.length > 0) {
                    const { renderFunction } = this.renderQueue.shift();

                    try {
                        await renderFunction();
                    } catch (error) {
                        console.error('‚ùå Render error:', error);
                    }

                    // Yield control if taking too long
                    if (performance.now() - startTime > 16) { // 16ms = 60fps
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                this.isRendering = false;
                this.updateRenderMetrics(performance.now() - startTime);
            }

            updateRenderMetrics(renderTime) {
                this.performanceMetrics.renderCount++;
                this.performanceMetrics.averageRenderTime =
                    (this.performanceMetrics.averageRenderTime * (this.performanceMetrics.renderCount - 1) + renderTime) /
                    this.performanceMetrics.renderCount;
            }

            updatePerformanceDisplay() {
                const renderTimeElement = document.getElementById('renderTime');
                const memoryElement = document.getElementById('memoryUsage');
                const fpsElement = document.getElementById('fps');

                if (renderTimeElement) {
                    renderTimeElement.textContent = Math.round(this.performanceMetrics.averageRenderTime);
                }

                if (memoryElement) {
                    memoryElement.textContent = this.performanceMetrics.memoryUsage;
                    // Add warning class if memory usage is high
                    if (this.performanceMetrics.memoryUsage > 80) {
                        memoryElement.className = 'memory-warning';
                    } else {
                        memoryElement.className = '';
                    }
                }

                if (fpsElement) {
                    fpsElement.textContent = this.performanceMetrics.frameRate;
                }

                // Update overlay
                this.updatePerformanceOverlay();
            }

            updatePerformanceOverlay() {
                const overlayRenderTime = document.getElementById('overlayRenderTime');
                const overlayMemoryUsage = document.getElementById('overlayMemoryUsage');
                const overlayFPS = document.getElementById('overlayFPS');
                const overlayCacheHitRate = document.getElementById('overlayCacheHitRate');
                const overlayRenderQueue = document.getElementById('overlayRenderQueue');

                if (overlayRenderTime) {
                    overlayRenderTime.textContent = Math.round(this.performanceMetrics.averageRenderTime) + 'ms';
                }

                if (overlayMemoryUsage) {
                    overlayMemoryUsage.textContent = this.performanceMetrics.memoryUsage + 'MB';
                    overlayMemoryUsage.className = this.performanceMetrics.memoryUsage > 80 ? 'performance-value error' : 'performance-value';
                }

                if (overlayFPS) {
                    overlayFPS.textContent = this.performanceMetrics.frameRate + ' FPS';
                    overlayFPS.className = this.performanceMetrics.frameRate < 30 ? 'performance-value warning' : 'performance-value';
                }

                if (overlayCacheHitRate) {
                    overlayCacheHitRate.textContent = Math.round(this.performanceMetrics.cacheHitRate * 100) + '%';
                    overlayCacheHitRate.className = this.performanceMetrics.cacheHitRate > 0.7 ? 'performance-value' : 'performance-value warning';
                }

                if (overlayRenderQueue) {
                    overlayRenderQueue.textContent = this.renderQueue.length;
                    overlayRenderQueue.className = this.renderQueue.length > 10 ? 'performance-value warning' : 'performance-value';
                }
            }

            // Lazy loading for large datasets
            shouldLazyLoad(data) {
                return Array.isArray(data) && data.length > this.lazyLoadThreshold;
            }

            createVirtualizedRenderer(data, container, itemHeight = 20) {
                const containerHeight = container.node().offsetHeight;
                const visibleItems = Math.ceil(containerHeight / itemHeight) + 2; // Buffer

                return {
                    data: data,
                    container: container,
                    itemHeight: itemHeight,
                    visibleItems: visibleItems,
                    scrollTop: 0,

                    render: function(startIndex = 0) {
                        const endIndex = Math.min(startIndex + this.visibleItems, this.data.length);
                        const visibleData = this.data.slice(startIndex, endIndex);

                        const selection = this.container.selectAll('.virtual-item')
                            .data(visibleData, d => d.id || d);

                        selection.enter()
                            .append('div')
                            .attr('class', 'virtual-item')
                            .style('height', this.itemHeight + 'px')
                            .style('position', 'absolute')
                            .merge(selection)
                            .style('top', (d, i) => ((startIndex + i) * this.itemHeight) + 'px');

                        selection.exit().remove();
                    },

                    updateScroll: function(scrollTop) {
                        const startIndex = Math.floor(scrollTop / this.itemHeight);
                        this.render(startIndex);
                    }
                };
            }
        }

        // Performance Monitor
        class PerformanceMonitor {
            constructor() {
                this.startTime = performance.now();
                this.frameCount = 0;
                this.lastTime = this.startTime;
                this.fps = 0;
                this.memoryUsage = 0;
            }

            start() {
                this.measurePerformance();
                setInterval(() => {
                    this.updateMetrics();
                }, 1000);
            }

            measurePerformance() {
                this.frameCount++;
                const currentTime = performance.now();

                if (currentTime - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }

                if (performance.memory) {
                    this.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                }

                requestAnimationFrame(() => this.measurePerformance());
            }

            updateMetrics() {
                document.getElementById('fps').textContent = this.fps;
                document.getElementById('memoryUsage').textContent = this.memoryUsage;
                document.getElementById('renderTime').textContent = Math.round(performance.now() - this.startTime);
            }
        }

        // Enhanced Real-time Data Stream Handler
        class RealTimeDataStream {
            constructor() {
                this.ws = null;
                this.dataBuffer = [];
                this.maxBufferSize = 1000; // Increased for better data retention
                this.compressionEnabled = true;
                this.streamingEnabled = false;
                this.updateFrequency = 100; // ms between updates
                this.lastUpdateTime = 0;
                this.dataValidators = new Map();
                this.errorCount = 0;
                this.maxErrors = 10;
                this.autoReconnect = true;
                this.reconnectDelay = 2000;
                this.performanceMetrics = {
                    updatesPerSecond: 0,
                    averageLatency: 0,
                    dataLossRate: 0
                };
                this.subscribers = new Set();

                this.initializeValidators();
            }

            initializeValidators() {
                // CPU usage validator
                this.dataValidators.set('cpuUsage', (value) => {
                    return typeof value === 'number' && value >= 0 && value <= 100;
                });

                // Memory usage validator
                this.dataValidators.set('memoryUsage', (value) => {
                    return typeof value === 'object' &&
                           typeof value.heapUsed === 'number' &&
                           typeof value.heapTotal === 'number';
                });

                // Response time validator
                this.dataValidators.set('responseTime', (value) => {
                    return typeof value === 'number' && value >= 0;
                });

                // Active connections validator
                this.dataValidators.set('activeConnections', (value) => {
                    return typeof value === 'number' && value >= 0;
                });
            }

            setWebSocket(ws) {
                this.ws = ws;
                this.setupWebSocketHandlers();
            }

            setupWebSocketHandlers() {
                if (!this.ws) return;

                this.ws.addEventListener('message', (event) => {
                    this.handleWebSocketMessage(event);
                });

                this.ws.addEventListener('close', () => {
                    console.log('üîå WebSocket connection lost');
                    if (this.autoReconnect) {
                        setTimeout(() => {
                            console.log('üîÑ Attempting to reconnect...');
                            this.reconnect();
                        }, this.reconnectDelay);
                    }
                });

                this.ws.addEventListener('error', (error) => {
                    console.error('‚ùå WebSocket error:', error);
                    this.errorCount++;
                    if (this.errorCount > this.maxErrors) {
                        console.error('üö´ Too many errors, disabling auto-reconnect');
                        this.autoReconnect = false;
                    }
                });
            }

            handleWebSocketMessage(event) {
                try {
                    const data = JSON.parse(event.data);
                    this.handleRealTimeUpdate(data);
                } catch (error) {
                    console.error('‚ùå Failed to parse WebSocket message:', error);
                    this.errorCount++;
                }
            }

            handleRealTimeUpdate(data) {
                if (!this.streamingEnabled) return;

                const currentTime = Date.now();

                // Throttle updates to prevent overwhelming the UI
                if (currentTime - this.lastUpdateTime < this.updateFrequency) {
                    return;
                }

                // Validate data
                if (!this.validateData(data)) {
                    console.warn('‚ö†Ô∏è Invalid data received:', data);
                    this.errorCount++;
                    return;
                }

                // Add timestamp and metadata
                const timestampedData = {
                    ...data,
                    timestamp: currentTime,
                    latency: currentTime - (data.timestamp || currentTime),
                    id: this.generateDataId()
                };

                // Advanced buffer management with compression
                this.addToBuffer(timestampedData);

                // Calculate performance metrics
                this.updatePerformanceMetrics(timestampedData);

                // Notify all subscribers
                this.notifySubscribers(timestampedData);

                this.lastUpdateTime = currentTime;
                this.errorCount = Math.max(0, this.errorCount - 1); // Decay error count
            }

            validateData(data) {
                if (!data || typeof data !== 'object') return false;

                // Check required fields
                const requiredFields = ['cpuUsage', 'memoryUsage', 'responseTime', 'activeConnections'];
                for (const field of requiredFields) {
                    if (!(field in data)) return false;
                }

                // Validate each field
                for (const [field, validator] of this.dataValidators) {
                    if (field in data && !validator(data[field])) {
                        return false;
                    }
                }

                return true;
            }

            generateDataId() {
                return `data_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            addToBuffer(data) {
                // Add with compression if enabled
                const compressedData = this.compressionEnabled ?
                    this.compressData(data) : data;

                this.dataBuffer.push(compressedData);

                // Intelligent buffer management
                if (this.dataBuffer.length > this.maxBufferSize) {
                    // Remove oldest 10% of data
                    const removeCount = Math.floor(this.maxBufferSize * 0.1);
                    this.dataBuffer.splice(0, removeCount);
                }

                // Update buffer statistics
                this.updateBufferStats();
            }

            compressData(data) {
                // Simple compression by removing redundant data
                const compressed = {
                    ...data,
                    // Keep only essential fields for compression
                    cpuUsage: Math.round(data.cpuUsage * 10) / 10,
                    responseTime: Math.round(data.responseTime),
                    activeConnections: Math.round(data.activeConnections)
                };

                if (data.memoryUsage) {
                    compressed.memoryUsage = {
                        heapUsed: Math.round(data.memoryUsage.heapUsed / 1024 / 1024), // Convert to MB
                        heapTotal: Math.round(data.memoryUsage.heapTotal / 1024 / 1024)
                    };
                }

                return compressed;
            }

            updatePerformanceMetrics(data) {
                const now = Date.now();

                // Calculate updates per second
                if (!this.performanceMetrics.lastMetricTime) {
                    this.performanceMetrics.lastMetricTime = now;
                    this.performanceMetrics.updateCount = 0;
                }

                this.performanceMetrics.updateCount++;

                if (now - this.performanceMetrics.lastMetricTime >= 1000) {
                    this.performanceMetrics.updatesPerSecond = this.performanceMetrics.updateCount;
                    this.performanceMetrics.updateCount = 0;
                    this.performanceMetrics.lastMetricTime = now;
                }

                // Calculate average latency
                if (data.latency !== undefined) {
                    const alpha = 0.1; // Smoothing factor
                    this.performanceMetrics.averageLatency =
                        (alpha * data.latency) + ((1 - alpha) * this.performanceMetrics.averageLatency);
                }

                // Calculate data loss rate
                this.performanceMetrics.dataLossRate = this.errorCount / Math.max(1, this.performanceMetrics.updateCount);
            }

            updateBufferStats() {
                const stats = {
                    size: this.dataBuffer.length,
                    maxSize: this.maxBufferSize,
                    utilization: (this.dataBuffer.length / this.maxBufferSize) * 100,
                    oldestData: this.dataBuffer.length > 0 ? this.dataBuffer[0].timestamp : null,
                    newestData: this.dataBuffer.length > 0 ? this.dataBuffer[this.dataBuffer.length - 1].timestamp : null
                };

                // Log buffer stats if utilization is high
                if (stats.utilization > 90) {
                    console.warn('‚ö†Ô∏è Data buffer utilization high:', stats.utilization.toFixed(1) + '%');
                }
            }

            subscribe(callback) {
                this.subscribers.add(callback);
                return () => this.subscribers.delete(callback);
            }

            notifySubscribers(data) {
                this.subscribers.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error('‚ùå Error in subscriber callback:', error);
                    }
                });
            }

            startStreaming() {
                this.streamingEnabled = true;
                this.lastUpdateTime = 0;
                this.errorCount = 0;
                console.log('üì° Real-time streaming started');
                this.notifySubscribers({ type: 'streaming_started', timestamp: Date.now() });
            }

            stopStreaming() {
                this.streamingEnabled = false;
                console.log('üì° Real-time streaming stopped');
                this.notifySubscribers({ type: 'streaming_stopped', timestamp: Date.now() });
            }

            getBufferedData() {
                return this.dataBuffer.map(data =>
                    this.compressionEnabled ? this.decompressData(data) : data
                );
            }

            decompressData(data) {
                // Reverse compression
                const decompressed = { ...data };

                if (data.memoryUsage && typeof data.memoryUsage.heapUsed === 'number') {
                    decompressed.memoryUsage = {
                        heapUsed: data.memoryUsage.heapUsed * 1024 * 1024, // Convert back to bytes
                        heapTotal: data.memoryUsage.heapTotal * 1024 * 1024
                    };
                }

                return decompressed;
            }

            clearBuffer() {
                this.dataBuffer = [];
                this.errorCount = 0;
                console.log('üóëÔ∏è Data buffer cleared');
                this.notifySubscribers({ type: 'buffer_cleared', timestamp: Date.now() });
            }

            getPerformanceMetrics() {
                return { ...this.performanceMetrics };
            }

            updateSettings(settings) {
                if (settings.maxBufferSize) {
                    this.maxBufferSize = Math.max(100, Math.min(10000, settings.maxBufferSize));
                }
                if (settings.updateFrequency) {
                    this.updateFrequency = Math.max(50, Math.min(1000, settings.updateFrequency));
                }
                if (settings.compressionEnabled !== undefined) {
                    this.compressionEnabled = settings.compressionEnabled;
                }
                if (settings.autoReconnect !== undefined) {
                    this.autoReconnect = settings.autoReconnect;
                }
                console.log('‚öôÔ∏è Data stream settings updated:', settings);
            }

            reconnect() {
                if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
                    console.log('üîÑ Reconnecting WebSocket...');
                    // The main dashboard will handle the reconnection
                    window.dispatchEvent(new CustomEvent('websocket-reconnect'));
                }
            }
        }

        // Enhanced Workflow Chart with ES Modules
        class EnhancedWorkflowChart {
            constructor(selector) {
                console.log('üîß Initializing EnhancedWorkflowChart with selector:', selector);
                this.container = d3.select(selector);

                // Check if container exists
                if (this.container.empty()) {
                    console.error('‚ùå Container not found:', selector);
                    return;
                }

                console.log('‚úÖ Container found, proceeding with chart creation');

                this.width = 800;
                this.height = 400;
                this.animationEnabled = true;
                this.zoomEnabled = false;
                this.brushEnabled = false;
                this.currentTransform = d3.zoomIdentity;

                this.svg = this.container.append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height);

                console.log('‚úÖ SVG created successfully');

                this.nodes = [
                    { id: 'start', name: 'Start', x: 100, y: 200, status: 'active' },
                    { id: 'process', name: 'Process', x: 300, y: 200, status: 'pending' },
                    { id: 'analyze', name: 'Analyze', x: 500, y: 200, status: 'pending' },
                    { id: 'end', name: 'End', x: 700, y: 200, status: 'pending' }
                ];

                this.links = [
                    { source: 'start', target: 'process', weight: 1 },
                    { source: 'process', target: 'analyze', weight: 1 },
                    { source: 'analyze', target: 'end', weight: 1 }
                ];

                this.setupInteractivity();
                this.render();
            }

            render() {
                console.log('üé® Rendering workflow chart...');

                // Clear previous render
                this.svg.selectAll('*').remove();

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.svg.selectAll('.chart-content')
                            .attr('transform', event.transform);
                    });

                this.svg.call(zoom);
                console.log('‚úÖ Zoom behavior added');

                // Create main group for zooming
                const chartContent = this.svg.append('g')
                    .attr('class', 'chart-content');
                console.log('‚úÖ Chart content group created');

                // Draw links
                console.log('üîó Drawing links:', this.links.length);
                const link = chartContent.selectAll('.link')
                    .data(this.links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('x1', d => this.nodes.find(n => n.id === d.source).x)
                    .attr('y1', d => this.nodes.find(n => n.id === d.source).y)
                    .attr('x2', d => this.nodes.find(n => n.id === d.target).x)
                    .attr('y2', d => this.nodes.find(n => n.id === d.target).y);
                console.log('‚úÖ Links drawn');

                // Draw nodes
                console.log('üîµ Drawing nodes:', this.nodes.length);
                const node = chartContent.selectAll('.node')
                    .data(this.nodes)
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x},${d.y})`);

                node.append('circle')
                    .attr('r', 30)
                    .attr('class', d => `node-${d.status}`)
                    .on('click', (event, d) => {
                        this.handleNodeClick(d);
                    })
                    .on('mouseover', (event, d) => {
                        this.showTooltip(event, d);
                    })
                    .on('mouseout', () => {
                        this.hideTooltip();
                    });

                node.append('text')
                    .text(d => d.name)
                    .attr('dy', 5);
                console.log('‚úÖ Nodes drawn');

                // Add animations if enabled
                if (this.animationEnabled) {
                    this.addAnimations();
                }
            }

            handleNodeClick(node) {
                console.log('Clicked node:', node.name);
                // Cycle through statuses
                const statuses = ['pending', 'active', 'completed', 'error'];
                const currentIndex = statuses.indexOf(node.status);
                node.status = statuses[(currentIndex + 1) % statuses.length];
                this.render();
            }

            showTooltip(event, node) {
                const tooltip = d3.select('#tooltip');
                tooltip.select('#tooltipContent').html(`
                    <strong>${node.name}</strong><br/>
                    Status: ${node.status}<br/>
                    Position: (${node.x}, ${node.y})
                `);
                tooltip
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .classed('show', true);
            }

            hideTooltip() {
                d3.select('#tooltip').classed('show', false);
            }

            addAnimations() {
                // Add pulsing animation to active nodes
                this.svg.selectAll('.node-active circle')
                    .transition()
                    .duration(1000)
                    .ease(d3.easeElasticOut)
                    .attr('r', 35)
                    .transition()
                    .duration(1000)
                    .ease(d3.easeElasticOut)
                    .attr('r', 30);
            }

            restart() {
                console.log('üîÑ Restarting enhanced workflow chart...');
                this.nodes.forEach(node => node.status = 'pending');
                this.render();
            }

            addRandomNode() {
                const newNode = {
                    id: `node_${Date.now()}`,
                    name: `Node ${this.nodes.length}`,
                    x: Math.random() * (this.width - 100) + 50,
                    y: Math.random() * (this.height - 100) + 50,
                    status: 'pending'
                };

                this.nodes.push(newNode);
                this.render();
            }

            toggleAnimation() {
                this.animationEnabled = !this.animationEnabled;
                console.log(`üé¨ Animation ${this.animationEnabled ? 'enabled' : 'disabled'}`);
                if (this.animationEnabled) {
                    this.addAnimations();
                }
            }

            exportSVG() {
                const svgData = new XMLSerializer().serializeToString(this.svg.node());
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'workflow-chart.svg';
                a.click();
                URL.revokeObjectURL(url);
            }

            updateWithData(data) {
                console.log('üìä Updating enhanced workflow chart with data:', data);
            }

            updateWithRealTimeData(data) {
                console.log('üì° Real-time workflow update:', data);

                // Check cache first
                const cacheKey = `workflow_${JSON.stringify(data)}`;
                const cached = window.enhancedD3Dashboard?.getCachedData(cacheKey);
                if (cached) {
                    console.log('üìã Using cached workflow data');
                    return;
                }

                // Update node statuses based on real-time data
                if (data.workflowStatus) {
                    this.nodes.forEach(node => {
                        if (data.workflowStatus[node.id]) {
                            node.status = data.workflowStatus[node.id];
                        }
                    });

                    // Cache the result
                    window.enhancedD3Dashboard?.setCachedData(cacheKey, data);

                    // Queue render for performance
                    if (window.enhancedD3Dashboard) {
                        window.enhancedD3Dashboard.queueRender(() => {
                            this.renderWithTransitions();
                        }, 1);
                    } else {
                        this.renderWithTransitions();
                    }
                }
            }

            renderWithTransitions() {
                // Re-render with smooth transitions
                const node = this.svg.selectAll('.node')
                    .data(this.nodes, d => d.id);

                node.select('circle')
                    .transition()
                    .duration(500)
                    .ease(d3.easeCubicInOut)
                    .attr('class', d => `node-${d.status}`);

                node.select('text')
                    .transition()
                    .duration(500)
                    .ease(d3.easeCubicInOut)
                    .text(d => d.name);
            }

            setupInteractivity() {
                // Add zoom indicator
                this.container.append('div')
                    .attr('class', 'zoom-indicator')
                    .attr('id', 'workflowZoomIndicator')
                    .text('Zoom: 100%');

                // Add navigation help
                this.container.append('div')
                    .attr('class', 'navigation-help')
                    .attr('id', 'workflowNavigationHelp')
                    .text('Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset');

                // Setup keyboard shortcuts
                this.setupKeyboardShortcuts();
            }

            setupKeyboardShortcuts() {
                d3.select(document).on('keydown.workflow', (event) => {
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

                    switch(event.key) {
                        case 'r':
                        case 'R':
                            if (event.ctrlKey) {
                                event.preventDefault();
                                this.restart();
                            }
                            break;
                        case 'z':
                        case 'Z':
                            if (event.ctrlKey) {
                                event.preventDefault();
                                this.resetView();
                            }
                            break;
                        case ' ':
                            event.preventDefault();
                            this.toggleZoom();
                            break;
                    }
                });
            }

            toggleZoom() {
                this.zoomEnabled = !this.zoomEnabled;

                if (this.zoomEnabled) {
                    this.addZoomBehavior();
                    document.getElementById('workflowNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to disable';
                } else {
                    this.removeZoomBehavior();
                    document.getElementById('workflowNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to enable';
                }

                console.log(`üîç Zoom ${this.zoomEnabled ? 'enabled' : 'disabled'}`);
            }

            addZoomBehavior() {
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.handleZoom(event);
                    })
                    .on('start', (event) => {
                        this.handleZoomStart(event);
                    })
                    .on('end', (event) => {
                        this.handleZoomEnd(event);
                    });

                this.svg.call(zoom);
                this.currentTransform = d3.zoomIdentity;
            }

            removeZoomBehavior() {
                this.svg.on('.zoom', null);
                this.resetView();
            }

            handleZoom(event) {
                this.currentTransform = event.transform;

                // Update chart content
                this.svg.selectAll('.chart-content')
                    .attr('transform', this.currentTransform);

                // Update zoom indicator
                const scale = Math.round(this.currentTransform.k * 100);
                document.getElementById('workflowZoomIndicator').textContent = `Zoom: ${scale}%`;
            }

            handleZoomStart(event) {
                this.container.style('cursor', 'grabbing');
            }

            handleZoomEnd(event) {
                this.container.style('cursor', 'default');
            }

            resetView() {
                this.currentTransform = d3.zoomIdentity;

                this.svg.transition()
                    .duration(750)
                    .call(d3.zoom().transform, this.currentTransform);

                document.getElementById('workflowZoomIndicator').textContent = 'Zoom: 100%';
                console.log('üè† View reset');
            }

            addBrushSelection() {
                // Add brush selection for node filtering
                const brush = d3.brush()
                    .extent([[0, 0], [this.width, this.height]])
                    .on('brush', (event) => {
                        this.handleBrush(event);
                    })
                    .on('end', (event) => {
                        this.handleBrushEnd(event);
                    });

                this.svg.append('g')
                    .attr('class', 'brush-layer')
                    .call(brush);
            }

            handleBrush(event) {
                if (!event.selection) return;

                const [[x0, y0], [x1, y1]] = event.selection;

                // Highlight nodes within brush selection
                this.svg.selectAll('.node')
                    .classed('selected', (d) => {
                        const [tx, ty] = this.currentTransform.apply([d.x, d.y]);
                        return tx >= x0 && tx <= x1 && ty >= y0 && ty <= y1;
                    });
            }

            handleBrushEnd(event) {
                if (!event.selection) {
                    // Clear selection
                    this.svg.selectAll('.node').classed('selected', false);
                    this.svg.select('.brush-layer').call(d3.brush().clear);
                }
            }

            toggleBrush() {
                this.brushEnabled = !this.brushEnabled;

                if (this.brushEnabled) {
                    this.addBrushSelection();
                } else {
                    this.svg.select('.brush-layer').remove();
                    this.svg.selectAll('.node').classed('selected', false);
                }

                console.log(`üñåÔ∏è Brush ${this.brushEnabled ? 'enabled' : 'disabled'}`);
            }

            resize() {
                const containerWidth = this.container.node().offsetWidth;
                if (containerWidth !== this.width) {
                    this.width = containerWidth;
                    this.svg.attr('width', this.width);

                    // Re-setup zoom if enabled
                    if (this.zoomEnabled) {
                        this.removeZoomBehavior();
                        this.addZoomBehavior();
                    }

                    this.render();
                }
            }
        }

        // Enhanced Performance Chart with ES Modules
        class EnhancedPerformanceChart {
            constructor(selector) {
                this.container = d3.select(selector);
                this.width = 800;
                this.height = 400;
                this.margin = { top: 20, right: 30, bottom: 40, left: 50 };
                this.chartType = 'bar'; // 'bar', 'line', 'area'
                this.zoomEnabled = false;
                this.brushEnabled = false;
                this.currentTransform = d3.zoomIdentity;

                this.svg = this.container.append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height);

                this.data = [
                    { name: 'CPU', value: 45, timestamp: Date.now() },
                    { name: 'Memory', value: 67, timestamp: Date.now() },
                    { name: 'Network', value: 23, timestamp: Date.now() },
                    { name: 'Disk', value: 89, timestamp: Date.now() },
                    { name: 'Response', value: 34, timestamp: Date.now() }
                ];

                this.setupInteractivity();
                this.render();
            }

            render() {
                // Clear previous render
                this.svg.selectAll('*').remove();

                const x = d3.scaleBand()
                    .domain(this.data.map(d => d.name))
                    .range([this.margin.left, this.width - this.margin.right])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => d.value)])
                    .range([this.height - this.margin.bottom, this.margin.top]);

                // Create main group for zooming
                const chartContent = this.svg.append('g')
                    .attr('class', 'chart-content');

                // Draw chart based on type
                switch (this.chartType) {
                    case 'bar':
                        this.renderBarChart(chartContent, x, y);
                        break;
                    case 'line':
                        this.renderLineChart(chartContent, x, y);
                        break;
                    case 'area':
                        this.renderAreaChart(chartContent, x, y);
                        break;
                }

                // Draw axes
                this.svg.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0,${this.height - this.margin.bottom})`)
                    .call(d3.axisBottom(x));

                this.svg.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(${this.margin.left},0)`)
                    .call(d3.axisLeft(y));

                // Add zoom if enabled
                if (this.zoomEnabled) {
                    this.addZoomBehavior();
                }
            }

            renderBarChart(content, x, y) {
                content.selectAll('.bar')
                    .data(this.data)
                    .enter()
                    .append('rect')
                    .attr('class', 'bar')
                    .attr('x', d => x(d.name))
                    .attr('y', d => y(d.value))
                    .attr('width', x.bandwidth())
                    .attr('height', d => y(0) - y(d.value))
                    .on('mouseover', (event, d) => {
                        this.showTooltip(event, d);
                    })
                    .on('mouseout', () => {
                        this.hideTooltip();
                    });
            }

            renderLineChart(content, x, y) {
                const line = d3.line()
                    .x(d => x(d.name) + x.bandwidth() / 2)
                    .y(d => y(d.value))
                    .curve(d3.curveMonotoneX);

                content.append('path')
                    .datum(this.data)
                    .attr('class', 'line')
                    .attr('d', line);
            }

            renderAreaChart(content, x, y) {
                const area = d3.area()
                    .x(d => x(d.name) + x.bandwidth() / 2)
                    .y0(y(0))
                    .y1(d => y(d.value))
                    .curve(d3.curveMonotoneX);

                content.append('path')
                    .datum(this.data)
                    .attr('class', 'area')
                    .attr('d', area);
            }

            addZoomBehavior() {
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.svg.selectAll('.chart-content')
                            .attr('transform', event.transform);
                    });

                this.svg.call(zoom);
            }

            showTooltip(event, d) {
                const tooltip = d3.select('#tooltip');
                tooltip.select('#tooltipContent').html(`
                    <strong>${d.name}</strong><br/>
                    Value: ${d.value}%<br/>
                    Timestamp: ${new Date(d.timestamp).toLocaleTimeString()}
                `);
                tooltip
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .classed('show', true);
            }

            hideTooltip() {
                d3.select('#tooltip').classed('show', false);
            }

            updateData() {
                console.log('üîÑ Updating enhanced performance chart...');
                this.data.forEach(d => {
                    d.value = Math.random() * 100;
                    d.timestamp = Date.now();
                });
                this.render();
            }

            toggleChartType() {
                const types = ['bar', 'line', 'area'];
                const currentIndex = types.indexOf(this.chartType);
                this.chartType = types[(currentIndex + 1) % types.length];
                console.log(`üìà Chart type changed to: ${this.chartType}`);
                this.render();
            }

            setupInteractivity() {
                // Add zoom indicator
                this.container.append('div')
                    .attr('class', 'zoom-indicator')
                    .attr('id', 'performanceZoomIndicator')
                    .text('Zoom: 100%');

                // Add navigation help
                this.container.append('div')
                    .attr('class', 'navigation-help')
                    .attr('id', 'performanceNavigationHelp')
                    .text('Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset');
            }

            toggleZoom() {
                this.zoomEnabled = !this.zoomEnabled;

                if (this.zoomEnabled) {
                    this.addZoomBehavior();
                    document.getElementById('performanceNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to disable';
                } else {
                    this.removeZoomBehavior();
                    document.getElementById('performanceNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to enable';
                }

                console.log(`üîç Zoom ${this.zoomEnabled ? 'enabled' : 'disabled'}`);
            }

            addZoomBehavior() {
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.handleZoom(event);
                    });

                this.svg.call(zoom);
                this.currentTransform = d3.zoomIdentity;
            }

            removeZoomBehavior() {
                this.svg.on('.zoom', null);
                this.resetView();
            }

            handleZoom(event) {
                this.currentTransform = event.transform;

                // Update chart content
                this.svg.selectAll('.chart-content')
                    .attr('transform', this.currentTransform);

                // Update zoom indicator
                const scale = Math.round(this.currentTransform.k * 100);
                document.getElementById('performanceZoomIndicator').textContent = `Zoom: ${scale}%`;
            }

            resetView() {
                this.currentTransform = d3.zoomIdentity;

                this.svg.transition()
                    .duration(750)
                    .call(d3.zoom().transform, this.currentTransform);

                document.getElementById('performanceZoomIndicator').textContent = 'Zoom: 100%';
                console.log('üè† View reset');
            }

            toggleBrush() {
                this.brushEnabled = !this.brushEnabled;

                if (this.brushEnabled) {
                    this.addBrushSelection();
                } else {
                    this.svg.select('.brush-layer').remove();
                    this.clearBrushSelection();
                }

                console.log(`üñåÔ∏è Brush ${this.brushEnabled ? 'enabled' : 'disabled'}`);
            }

            addBrushSelection() {
                // Add brush selection for data filtering
                const brush = d3.brushX()
                    .extent([[this.margin.left, this.margin.top], [this.width - this.margin.right, this.height - this.margin.bottom]])
                    .on('brush', (event) => {
                        this.handleBrush(event);
                    })
                    .on('end', (event) => {
                        this.handleBrushEnd(event);
                    });

                this.svg.append('g')
                    .attr('class', 'brush-layer')
                    .call(brush);
            }

            handleBrush(event) {
                if (!event.selection) return;

                const [x0, x1] = event.selection;

                // Filter data based on brush selection
                const x = d3.scaleBand()
                    .domain(this.data.map(d => d.name))
                    .range([this.margin.left, this.width - this.margin.right])
                    .padding(0.1);

                const filteredData = this.data.filter(d => {
                    const barX = x(d.name);
                    const barWidth = x.bandwidth();
                    return barX + barWidth >= x0 && barX <= x1;
                });

                // Highlight filtered data
                this.svg.selectAll('.bar')
                    .classed('selected', (d) => filteredData.includes(d));
            }

            handleBrushEnd(event) {
                if (!event.selection) {
                    this.clearBrushSelection();
                }
            }

            clearBrushSelection() {
                this.svg.selectAll('.bar').classed('selected', false);
                this.svg.select('.brush-layer').call(d3.brush().clear);
            }

            exportChart() {
                const svgData = new XMLSerializer().serializeToString(this.svg.node());
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'performance-chart.svg';
                a.click();
                URL.revokeObjectURL(url);
            }

            enableZoom() {
                this.zoomEnabled = true;
                this.addZoomBehavior();
                console.log('üîç Zoom enabled');
            }

            resetZoom() {
                this.resetView();
                console.log('üè† Zoom reset');
            }

            updateWithData(data) {
                console.log('üìä Updating enhanced performance chart with real data');
                if (data.cpuUsage !== undefined) {
                    this.data[0].value = data.cpuUsage;
                    this.data[0].timestamp = Date.now();
                }
                if (data.memoryUsage && data.memoryUsage.heapUsed) {
                    this.data[1].value = (data.memoryUsage.heapUsed / data.memoryUsage.heapTotal) * 100;
                    this.data[1].timestamp = Date.now();
                }
                if (data.responseTime !== undefined) {
                    this.data[4].value = Math.min(data.responseTime / 10, 100);
                    this.data[4].timestamp = Date.now();
                }
                this.render();
            }

            updateWithRealTimeData(data) {
                console.log('üì° Real-time performance update:', data);

                // Check cache first
                const cacheKey = `performance_${data.timestamp}_${data.cpuUsage}_${data.responseTime}`;
                const cached = window.enhancedD3Dashboard?.getCachedData(cacheKey);
                if (cached) {
                    console.log('üìã Using cached performance data');
                    return;
                }

                // Update data with smooth transitions
                const oldData = [...this.data];

                if (data.cpuUsage !== undefined) {
                    this.data[0].value = data.cpuUsage;
                    this.data[0].timestamp = data.timestamp || Date.now();
                }
                if (data.memoryUsage && data.memoryUsage.heapUsed) {
                    this.data[1].value = (data.memoryUsage.heapUsed / data.memoryUsage.heapTotal) * 100;
                    this.data[1].timestamp = data.timestamp || Date.now();
                }
                if (data.responseTime !== undefined) {
                    this.data[4].value = Math.min(data.responseTime / 10, 100);
                    this.data[4].timestamp = data.timestamp || Date.now();
                }

                // Cache the result
                window.enhancedD3Dashboard?.setCachedData(cacheKey, data);

                // Queue render for performance
                if (window.enhancedD3Dashboard) {
                    window.enhancedD3Dashboard.queueRender(() => {
                        this.renderWithRealTimeTransitions(oldData);
                    }, 2);
                } else {
                    this.renderWithRealTimeTransitions(oldData);
                }
            }

            renderWithRealTimeTransitions(oldData) {
                const x = d3.scaleBand()
                    .domain(this.data.map(d => d.name))
                    .range([this.margin.left, this.width - this.margin.right])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => d.value)])
                    .range([this.height - this.margin.bottom, this.margin.top]);

                // Update bars with smooth transitions
                const bars = this.svg.selectAll('.bar')
                    .data(this.data, d => d.name);

                bars.transition()
                    .duration(300)
                    .ease(d3.easeCubicInOut)
                    .attr('y', d => y(d.value))
                    .attr('height', d => y(0) - y(d.value));

                // Update line if in line chart mode
                if (this.chartType === 'line') {
                    const line = d3.line()
                        .x(d => x(d.name) + x.bandwidth() / 2)
                        .y(d => y(d.value))
                        .curve(d3.curveMonotoneX);

                    this.svg.selectAll('.line')
                        .transition()
                        .duration(300)
                        .ease(d3.easeCubicInOut)
                        .attr('d', line);
                }

                // Update area if in area chart mode
                if (this.chartType === 'area') {
                    const area = d3.area()
                        .x(d => x(d.name) + x.bandwidth() / 2)
                        .y0(y(0))
                        .y1(d => y(d.value))
                        .curve(d3.curveMonotoneX);

                    this.svg.selectAll('.area')
                        .transition()
                        .duration(300)
                        .ease(d3.easeCubicInOut)
                        .attr('d', area);
                }
            }

            resize() {
                const containerWidth = this.container.node().offsetWidth;
                if (containerWidth !== this.width) {
                    this.width = containerWidth;
                    this.svg.attr('width', this.width);
                    this.render();
                }
            }
        }

        // Real-time Line Chart with ES Modules
        class RealTimeLineChart {
            constructor(selector) {
                this.container = d3.select(selector);
                this.width = 800;
                this.height = 400;
                this.margin = { top: 20, right: 30, bottom: 40, left: 50 };
                this.data = [];
                this.maxDataPoints = 50;
                this.streaming = false;
                this.zoomEnabled = false;
                this.brushEnabled = false;
                this.currentTransform = d3.zoomIdentity;

                this.svg = this.container.append('svg')
                    .attr('width', this.width)
                    .attr('height', this.height);

                this.setupInteractivity();
                this.render();
            }

            render() {
                // Clear previous render
                this.svg.selectAll('*').remove();

                if (this.data.length === 0) {
                    this.svg.append('text')
                        .attr('x', this.width / 2)
                        .attr('y', this.height / 2)
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'var(--secondary-text)')
                        .text('Click "Start Streaming" to begin...');
                    return;
                }

                const x = d3.scaleTime()
                    .domain(d3.extent(this.data, d => d.timestamp))
                    .range([this.margin.left, this.width - this.margin.right]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => d.value)])
                    .range([this.height - this.margin.bottom, this.margin.top]);

                // Create line generator
                const line = d3.line()
                    .x(d => x(d.timestamp))
                    .y(d => y(d.value))
                    .curve(d3.curveMonotoneX);

                // Draw line
                this.svg.append('path')
                    .datum(this.data)
                    .attr('class', 'line')
                    .attr('d', line);

                // Draw axes
                this.svg.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(0,${this.height - this.margin.bottom})`)
                    .call(d3.axisBottom(x).tickFormat(d3.timeFormat('%H:%M:%S')));

                this.svg.append('g')
                    .attr('class', 'axis')
                    .attr('transform', `translate(${this.margin.left},0)`)
                    .call(d3.axisLeft(y));
            }

            addDataPoint(data) {
                const newPoint = {
                    timestamp: Date.now(),
                    value: data.cpuUsage || Math.random() * 100
                };

                this.data.push(newPoint);

                // Keep only recent data points
                if (this.data.length > this.maxDataPoints) {
                    this.data.shift();
                }

                this.render();
            }

            addRealTimeDataPoint(data) {
                const newPoint = {
                    timestamp: data.timestamp || Date.now(),
                    value: data.cpuUsage || Math.random() * 100,
                    latency: data.latency || 0,
                    id: data.id || `point_${Date.now()}`
                };

                // Check cache first
                const cacheKey = `line_${newPoint.timestamp}_${newPoint.value}`;
                const cached = window.enhancedD3Dashboard?.getCachedData(cacheKey);
                if (cached) {
                    console.log('üìã Using cached line chart data');
                    return;
                }

                this.data.push(newPoint);

                // Keep only recent data points
                if (this.data.length > this.maxDataPoints) {
                    this.data.shift();
                }

                // Cache the result
                window.enhancedD3Dashboard?.setCachedData(cacheKey, newPoint);

                // Queue render for performance with high priority for real-time data
                if (window.enhancedD3Dashboard) {
                    window.enhancedD3Dashboard.queueRender(() => {
                        this.renderWithRealTimeTransitions();
                    }, 3); // High priority for real-time updates
                } else {
                    this.renderWithRealTimeTransitions();
                }
            }

            renderWithRealTimeTransitions() {
                if (this.data.length === 0) return;

                const x = d3.scaleTime()
                    .domain(d3.extent(this.data, d => d.timestamp))
                    .range([this.margin.left, this.width - this.margin.right]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => d.value)])
                    .range([this.height - this.margin.bottom, this.margin.top]);

                // Create line generator
                const line = d3.line()
                    .x(d => x(d.timestamp))
                    .y(d => y(d.value))
                    .curve(d3.curveMonotoneX);

                // Update line with smooth transition
                const linePath = this.svg.selectAll('.line')
                    .data([this.data]);

                linePath.enter()
                    .append('path')
                    .attr('class', 'line')
                    .merge(linePath)
                    .transition()
                    .duration(200)
                    .ease(d3.easeLinear)
                    .attr('d', line);

                // Update axes with smooth transitions
                this.svg.select('.x-axis')
                    .transition()
                    .duration(200)
                    .call(d3.axisBottom(x).tickFormat(d3.timeFormat('%H:%M:%S')));

                this.svg.select('.y-axis')
                    .transition()
                    .duration(200)
                    .call(d3.axisLeft(y));
            }

            startStreaming() {
                this.streaming = true;
                console.log('‚ñ∂Ô∏è Real-time streaming started');
                document.getElementById('lineChartLoading').style.display = 'inline-block';
            }

            stopStreaming() {
                this.streaming = false;
                console.log('‚è∏Ô∏è Real-time streaming stopped');
                document.getElementById('lineChartLoading').style.display = 'none';
            }

            clearData() {
                this.data = [];
                this.render();
                console.log('üóëÔ∏è Line chart data cleared');
            }

            exportData() {
                const csvData = this.data.map(d => `${new Date(d.timestamp).toISOString()},${d.value}`).join('\n');
                const blob = new Blob([`timestamp,value\n${csvData}`], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'line-chart-data.csv';
                a.click();
                URL.revokeObjectURL(url);
            }

            setupInteractivity() {
                // Add zoom indicator
                this.container.append('div')
                    .attr('class', 'zoom-indicator')
                    .attr('id', 'lineChartZoomIndicator')
                    .text('Zoom: 100%');

                // Add navigation help
                this.container.append('div')
                    .attr('class', 'navigation-help')
                    .attr('id', 'lineChartNavigationHelp')
                    .text('Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset');
            }

            toggleZoom() {
                this.zoomEnabled = !this.zoomEnabled;

                if (this.zoomEnabled) {
                    this.addZoomBehavior();
                    document.getElementById('lineChartNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to disable';
                } else {
                    this.removeZoomBehavior();
                    document.getElementById('lineChartNavigationHelp').textContent = 'Drag to pan ‚Ä¢ Wheel to zoom ‚Ä¢ Double-click to reset ‚Ä¢ Space to enable';
                }

                console.log(`üîç Zoom ${this.zoomEnabled ? 'enabled' : 'disabled'}`);
            }

            addZoomBehavior() {
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.handleZoom(event);
                    });

                this.svg.call(zoom);
                this.currentTransform = d3.zoomIdentity;
            }

            removeZoomBehavior() {
                this.svg.on('.zoom', null);
                this.resetView();
            }

            handleZoom(event) {
                this.currentTransform = event.transform;

                // Update chart content
                this.svg.selectAll('.chart-content')
                    .attr('transform', this.currentTransform);

                // Update zoom indicator
                const scale = Math.round(this.currentTransform.k * 100);
                document.getElementById('lineChartZoomIndicator').textContent = `Zoom: ${scale}%`;
            }

            resetView() {
                this.currentTransform = d3.zoomIdentity;

                this.svg.transition()
                    .duration(750)
                    .call(d3.zoom().transform, this.currentTransform);

                document.getElementById('lineChartZoomIndicator').textContent = 'Zoom: 100%';
                console.log('üè† Line chart view reset');
            }

            toggleBrush() {
                this.brushEnabled = !this.brushEnabled;

                if (this.brushEnabled) {
                    this.addBrushSelection();
                } else {
                    this.svg.select('.brush-layer').remove();
                    this.clearBrushSelection();
                }

                console.log(`üñåÔ∏è Brush ${this.brushEnabled ? 'enabled' : 'disabled'}`);
            }

            addBrushSelection() {
                // Add brush selection for time range filtering
                const brush = d3.brushX()
                    .extent([[this.margin.left, this.margin.top], [this.width - this.margin.right, this.height - this.margin.bottom]])
                    .on('brush', (event) => {
                        this.handleBrush(event);
                    })
                    .on('end', (event) => {
                        this.handleBrushEnd(event);
                    });

                this.svg.append('g')
                    .attr('class', 'brush-layer')
                    .call(brush);
            }

            handleBrush(event) {
                if (!event.selection || this.data.length === 0) return;

                const [x0, x1] = event.selection;

                // Filter data based on time range
                const x = d3.scaleTime()
                    .domain(d3.extent(this.data, d => d.timestamp))
                    .range([this.margin.left, this.width - this.margin.right]);

                const filteredData = this.data.filter(d => {
                    const dataX = x(d.timestamp);
                    return dataX >= x0 && dataX <= x1;
                });

                // Highlight filtered data points
                this.svg.selectAll('.data-point')
                    .classed('selected', (d) => filteredData.includes(d));
            }

            handleBrushEnd(event) {
                if (!event.selection) {
                    this.clearBrushSelection();
                }
            }

            clearBrushSelection() {
                this.svg.selectAll('.data-point').classed('selected', false);
                this.svg.select('.brush-layer').call(d3.brush().clear);
            }

            resetZoom() {
                this.resetView();
                console.log('üè† Line chart zoom reset');
            }

            restart() {
                this.clearData();
                this.startStreaming();
            }

            resize() {
                const containerWidth = this.container.node().offsetWidth;
                if (containerWidth !== this.width) {
                    this.width = containerWidth;
                    this.svg.attr('width', this.width);

                    // Re-setup zoom if enabled
                    if (this.zoomEnabled) {
                        this.removeZoomBehavior();
                        this.addZoomBehavior();
                    }

                    this.render();
                }
            }
        }

        // Essential Chart Types Classes
        class LineChart {
            constructor(container, data, options = {}) {
                this.container = d3.select(container);
                this.data = data || this.generateSampleData();
                this.options = {
                    width: 800,
                    height: 400,
                    margin: { top: 20, right: 30, bottom: 40, left: 40 },
                    ...options
                };
                this.init();
            }

            init() {
                this.width = this.options.width - this.options.margin.left - this.options.margin.right;
                this.height = this.options.height - this.options.margin.top - this.options.margin.bottom;

                this.svg = this.container
                    .append('svg')
                    .attr('width', this.options.width)
                    .attr('height', this.options.height);

                this.g = this.svg
                    .append('g')
                    .attr('transform', `translate(${this.options.margin.left},${this.options.margin.top})`);

                this.setupScales();
                this.setupAxes();
                this.render();
            }

            setupScales() {
                this.xScale = d3.scaleLinear()
                    .domain(d3.extent(this.data, d => d.x))
                    .range([0, this.width]);

                this.yScale = d3.scaleLinear()
                    .domain(d3.extent(this.data, d => d.y))
                    .range([this.height, 0]);
            }

            setupAxes() {
                this.xAxis = d3.axisBottom(this.xScale);
                this.yAxis = d3.axisLeft(this.yScale);

                this.g.append('g')
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0,${this.height})`)
                    .call(this.xAxis);

                this.g.append('g')
                    .attr('class', 'y-axis')
                    .call(this.yAxis);
            }

            render() {
                const line = d3.line()
                    .x(d => this.xScale(d.x))
                    .y(d => this.yScale(d.y))
                    .curve(d3.curveCardinal);

                this.g.selectAll('.line').remove();
                this.g.append('path')
                    .datum(this.data)
                    .attr('class', 'line')
                    .attr('d', line);

                this.g.selectAll('.chart-point').remove();
                this.g.selectAll('.chart-point')
                    .data(this.data)
                    .enter()
                    .append('circle')
                    .attr('class', 'chart-point')
                    .attr('cx', d => this.xScale(d.x))
                    .attr('cy', d => this.yScale(d.y))
                    .attr('r', 4)
                    .on('mouseover', (event, d) => this.showTooltip(event, d))
                    .on('mouseout', () => this.hideTooltip());
            }

            generateSampleData() {
                return d3.range(20).map(i => ({
                    x: i,
                    y: Math.sin(i * 0.5) * 50 + 100 + Math.random() * 20
                }));
            }

            showTooltip(event, d) {
                const tooltip = d3.select('#tooltip');
                const timestamp = new Date().toLocaleTimeString();
                const trend = this.calculateTrend(d);

                tooltip.select('#tooltipContent').html(`
                    <div style="border-bottom: 1px solid var(--accent-bg); margin-bottom: 8px; padding-bottom: 4px;">
                        <strong>üìä Data Point Details</strong>
                    </div>
                    <div style="margin-bottom: 4px;">
                        <strong>X Value:</strong> ${d.x.toFixed(2)}
                    </div>
                    <div style="margin-bottom: 4px;">
                        <strong>Y Value:</strong> ${d.y.toFixed(2)}
                    </div>
                    <div style="margin-bottom: 4px;">
                        <strong>Timestamp:</strong> ${timestamp}
                    </div>
                    <div style="margin-bottom: 4px;">
                        <strong>Trend:</strong> ${trend}
                    </div>
                    <div style="font-size: 11px; color: var(--secondary-text); margin-top: 8px;">
                        üí° Click to highlight ‚Ä¢ Hover to explore
                    </div>
                `);

                // Smart positioning to avoid screen edges
                const tooltipRect = tooltip.node().getBoundingClientRect();
                let left = event.pageX + 10;
                let top = event.pageY - 10;

                if (left + tooltipRect.width > window.innerWidth) {
                    left = event.pageX - tooltipRect.width - 10;
                }
                if (top < 0) {
                    top = event.pageY + 10;
                }

                tooltip
                    .style('left', left + 'px')
                    .style('top', top + 'px')
                    .classed('show', true);
            }

            calculateTrend(d) {
                // Simple trend calculation based on surrounding points
                const index = this.data.findIndex(point => point.x === d.x);
                if (index > 0 && index < this.data.length - 1) {
                    const prev = this.data[index - 1];
                    const next = this.data[index + 1];
                    const diff = next.y - prev.y;

                    if (diff > 5) return 'üìà Rising';
                    if (diff < -5) return 'üìâ Falling';
                    return 'üìä Stable';
                }
                return 'üìä Unknown';
            }

            hideTooltip() {
                d3.select('#tooltip').classed('show', false);
            }

            updateData(newData) {
                this.data = newData || this.generateSampleData();
                this.setupScales();
                this.setupAxes();
                this.render();
            }
        }

        class AreaChart {
            constructor(container, data, options = {}) {
                this.container = d3.select(container);
                this.data = data || this.generateSampleData();
                this.options = {
                    width: 800,
                    height: 400,
                    margin: { top: 20, right: 30, bottom: 40, left: 40 },
                    ...options
                };
                this.init();
            }

            init() {
                this.width = this.options.width - this.options.margin.left - this.options.margin.right;
                this.height = this.options.height - this.options.margin.top - this.options.margin.bottom;

                this.svg = this.container
                    .append('svg')
                    .attr('width', this.options.width)
                    .attr('height', this.options.height);

                // Add gradient definition
                const defs = this.svg.append('defs');
                const gradient = defs.append('linearGradient')
                    .attr('id', 'areaGradient')
                    .attr('x1', '0%')
                    .attr('y1', '0%')
                    .attr('x2', '0%')
                    .attr('y2', '100%');

                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', 'var(--accent-color)')
                    .attr('stop-opacity', 0.8);

                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', 'var(--accent-color)')
                    .attr('stop-opacity', 0.1);

                this.g = this.svg
                    .append('g')
                    .attr('transform', `translate(${this.options.margin.left},${this.options.margin.top})`);

                this.setupScales();
                this.setupAxes();
                this.render();
            }

            setupScales() {
                this.xScale = d3.scaleLinear()
                    .domain(d3.extent(this.data, d => d.x))
                    .range([0, this.width]);

                this.yScale = d3.scaleLinear()
                    .domain([0, d3.max(this.data, d => d.y)])
                    .range([this.height, 0]);
            }

            setupAxes() {
                this.xAxis = d3.axisBottom(this.xScale);
                this.yAxis = d3.axisLeft(this.yScale);

                this.g.append('g')
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0,${this.height})`)
                    .call(this.xAxis);

                this.g.append('g')
                    .attr('class', 'y-axis')
                    .call(this.yAxis);
            }

            render() {
                const area = d3.area()
                    .x(d => this.xScale(d.x))
                    .y0(this.height)
                    .y1(d => this.yScale(d.y))
                    .curve(d3.curveCardinal);

                const line = d3.line()
                    .x(d => this.xScale(d.x))
                    .y(d => this.yScale(d.y))
                    .curve(d3.curveCardinal);

                this.g.selectAll('.area').remove();
                this.g.append('path')
                    .datum(this.data)
                    .attr('class', 'area')
                    .attr('d', area);

                this.g.selectAll('.line').remove();
                this.g.append('path')
                    .datum(this.data)
                    .attr('class', 'line')
                    .attr('d', line);
            }

            generateSampleData() {
                return d3.range(30).map(i => ({
                    x: i,
                    y: Math.abs(Math.sin(i * 0.3) * 100) + Math.random() * 30
                }));
            }

            updateData(newData) {
                this.data = newData || this.generateSampleData();
                this.setupScales();
                this.setupAxes();
                this.render();
            }
        }

        class GaugeChart {
            constructor(container, value, options = {}) {
                this.container = d3.select(container);
                this.value = value || Math.random() * 100;
                this.options = {
                    width: 300,
                    height: 300,
                    min: 0,
                    max: 100,
                    ...options
                };
                this.init();
            }

            init() {
                const radius = Math.min(this.options.width, this.options.height) / 2 - 10;
                this.radius = radius;

                this.svg = this.container
                    .append('svg')
                    .attr('width', this.options.width)
                    .attr('height', this.options.height);

                this.g = this.svg
                    .append('g')
                    .attr('transform', `translate(${this.options.width / 2},${this.options.height / 2})`);

                this.render();
            }

            render() {
                const arc = d3.arc()
                    .innerRadius(this.radius * 0.6)
                    .outerRadius(this.radius)
                    .startAngle(0)
                    .endAngle(Math.PI * 2);

                const valueArc = d3.arc()
                    .innerRadius(this.radius * 0.6)
                    .outerRadius(this.radius)
                    .startAngle(0)
                    .endAngle((this.value / this.options.max) * Math.PI * 2);

                // Background arc
                this.g.selectAll('.background-arc').remove();
                this.g.append('path')
                    .attr('class', 'background-arc')
                    .attr('d', arc)
                    .attr('fill', 'var(--accent-bg)')
                    .attr('stroke', 'var(--accent-color)')
                    .attr('stroke-width', 2);

                // Value arc
                this.g.selectAll('.value-arc').remove();
                this.g.append('path')
                    .attr('class', 'value-arc')
                    .attr('d', valueArc)
                    .attr('fill', 'var(--accent-color)')
                    .attr('opacity', 0.8);

                // Value text
                this.g.selectAll('.gauge-value').remove();
                this.g.append('text')
                    .attr('class', 'gauge-value')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .text(`${this.value.toFixed(1)}%`);

                // Label
                this.g.selectAll('.gauge-label').remove();
                this.g.append('text')
                    .attr('class', 'gauge-label')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '2em')
                    .text(this.options.label || 'Value');
            }

            updateValue(newValue) {
                this.value = newValue;
                this.render();
            }
        }

        // Global variables for essential charts
        let currentChart = null;
        let currentChartType = 'line';

        // Global functions for essential charts
        function switchChartType(type) {
            currentChartType = type;
            const container = d3.select('#essential-charts');
            container.selectAll('*').remove();

            const sampleData = generateSampleDataForType(type);

            switch(type) {
                case 'line':
                    currentChart = new LineChart('#essential-charts', sampleData);
                    break;
                case 'area':
                    currentChart = new AreaChart('#essential-charts', sampleData);
                    break;
                case 'gauge':
                    currentChart = new GaugeChart('#essential-charts', Math.random() * 100, {
                        label: 'CPU Usage'
                    });
                    break;
            }
        }

        function generateSampleDataForType(type) {
            if (type === 'gauge') return null;

            return d3.range(20).map(i => ({
                x: i,
                y: Math.sin(i * 0.5) * 50 + 100 + Math.random() * 20
            }));
        }

        function updateChartData() {
            if (currentChart) {
                if (currentChartType === 'gauge') {
                    currentChart.updateValue(Math.random() * 100);
                } else {
                    const newData = generateSampleDataForType(currentChartType);
                    currentChart.updateData(newData);
                }
            }
        }

        function exportCurrentChart() {
            if (currentChart && currentChart.svg) {
                const svgData = currentChart.svg.node().outerHTML;
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentChartType}-chart.svg`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function exportChartAsCSV() {
            if (currentChart && currentChart.data) {
                let csvContent = '';

                if (currentChartType === 'gauge') {
                    // For gauge chart, export the value
                    csvContent = 'Metric,Value\n';
                    csvContent += `${currentChart.options.label || 'Value'},${currentChart.value.toFixed(2)}\n`;
                } else {
                    // For line and area charts, export the data points
                    csvContent = 'X,Y\n';
                    currentChart.data.forEach(point => {
                        csvContent += `${point.x},${point.y.toFixed(2)}\n`;
                    });
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentChartType}-chart-data.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function toggleChartAnimation() {
            // Simple animation toggle - could be expanded
            console.log('Chart animation toggled');
        }

        // Global streaming control functions
        function startRealTimeStreaming() {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                window.enhancedD3Dashboard.dataStream.startStreaming();
                if (window.lineChart) {
                    window.lineChart.startStreaming();
                }
                console.log('üì° Real-time streaming started globally');
            }
        }

        function stopRealTimeStreaming() {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                window.enhancedD3Dashboard.dataStream.stopStreaming();
                if (window.lineChart) {
                    window.lineChart.stopStreaming();
                }
                console.log('‚è∏Ô∏è Real-time streaming stopped globally');
            }
        }

        function clearStreamingData() {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                window.enhancedD3Dashboard.dataStream.clearBuffer();
                if (window.lineChart) {
                    window.lineChart.clearData();
                }
                console.log('üóëÔ∏è Streaming data cleared globally');
            }
        }

        function exportStreamingData() {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                const data = window.enhancedD3Dashboard.dataStream.getBufferedData();
                const csvData = data.map(d =>
                    `${new Date(d.timestamp).toISOString()},${d.cpuUsage},${d.memoryUsage?.heapUsed || 0},${d.responseTime},${d.activeConnections}`
                ).join('\n');

                const blob = new Blob([`timestamp,cpuUsage,memoryUsed,responseTime,activeConnections\n${csvData}`], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'streaming-data.csv';
                a.click();
                URL.revokeObjectURL(url);
                console.log('üíæ Streaming data exported');
            }
        }

        function showStreamingSettings() {
            const modal = document.getElementById('streamingSettingsModal');
            modal.style.display = 'block';

            // Update performance metrics
            updateStreamingMetrics();

            // Start metrics update interval
            if (!window.streamingMetricsInterval) {
                window.streamingMetricsInterval = setInterval(updateStreamingMetrics, 1000);
            }
        }

        function closeStreamingSettings() {
            const modal = document.getElementById('streamingSettingsModal');
            modal.style.display = 'none';

            // Clear metrics update interval
            if (window.streamingMetricsInterval) {
                clearInterval(window.streamingMetricsInterval);
                window.streamingMetricsInterval = null;
            }
        }

        function updateStreamingSetting(setting, value) {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                const settings = {};
                settings[setting] = value;
                window.enhancedD3Dashboard.dataStream.updateSettings(settings);

                // Update UI
                if (setting === 'maxBufferSize') {
                    document.getElementById('bufferSizeValue').textContent = value;
                } else if (setting === 'updateFrequency') {
                    document.getElementById('updateFrequencyValue').textContent = value;
                }
            }
        }

        function updateStreamingMetrics() {
            if (window.enhancedD3Dashboard && window.enhancedD3Dashboard.dataStream) {
                const metrics = window.enhancedD3Dashboard.dataStream.getPerformanceMetrics();

                document.getElementById('updatesPerSecond').textContent = metrics.updatesPerSecond;
                document.getElementById('averageLatency').textContent = Math.round(metrics.averageLatency);
                document.getElementById('dataLossRate').textContent = (metrics.dataLossRate * 100).toFixed(2);
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('streamingSettingsModal');
            if (event.target === modal) {
                closeStreamingSettings();
            }
        }

        // Performance control functions
        function togglePerformanceOverlay() {
            const overlay = document.getElementById('performanceOverlay');
            if (overlay) {
                overlay.classList.toggle('hidden');
            }
        }

        function triggerGarbageCollection() {
            if (window.enhancedD3Dashboard) {
                window.enhancedD3Dashboard.triggerGarbageCollection();
                console.log('üóëÔ∏è Manual garbage collection triggered');
            }
        }

        function clearAllCaches() {
            if (window.enhancedD3Dashboard) {
                window.enhancedD3Dashboard.cache.clear();
                console.log('üóëÔ∏è All caches cleared');
            }
        }

        function toggleVirtualization() {
            if (window.enhancedD3Dashboard) {
                window.enhancedD3Dashboard.virtualizationEnabled = !window.enhancedD3Dashboard.virtualizationEnabled;
                console.log(`üéØ Virtualization ${window.enhancedD3Dashboard.virtualizationEnabled ? 'enabled' : 'disabled'}`);
            }
        }

        function getPerformanceReport() {
            if (window.enhancedD3Dashboard) {
                const report = {
                    renderCount: window.enhancedD3Dashboard.performanceMetrics.renderCount,
                    averageRenderTime: window.enhancedD3Dashboard.performanceMetrics.averageRenderTime,
                    memoryUsage: window.enhancedD3Dashboard.performanceMetrics.memoryUsage,
                    cacheHitRate: window.enhancedD3Dashboard.performanceMetrics.cacheHitRate,
                    frameRate: window.enhancedD3Dashboard.performanceMetrics.frameRate,
                    cacheSize: window.enhancedD3Dashboard.cache.size,
                    renderQueueSize: window.enhancedD3Dashboard.renderQueue.length,
                    virtualizationEnabled: window.enhancedD3Dashboard.virtualizationEnabled
                };

                console.log('üìä Performance Report:', report);
                return report;
            }
        }

        // Initialize enhanced dashboard
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Starting Enhanced D3 Dashboard with ES Modules...');

            // Wait for D3.js to be ready
            if (window.d3Ready) {
                window.enhancedD3Dashboard = new EnhancedD3Dashboard();
                // Initialize essential charts
                setTimeout(() => {
                    switchChartType('line'); // Start with line chart
                }, 1000);
            } else {
                window.addEventListener('d3Ready', () => {
                    console.log('üéØ D3.js ready, initializing dashboard...');
                    window.enhancedD3Dashboard = new EnhancedD3Dashboard();
                    // Initialize essential charts
                    setTimeout(() => {
                        switchChartType('line'); // Start with line chart
                    }, 1000);
                });
            }
        });
    </script>
</body>
</html>
