<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚀 TappMCP D3.js Visualizations Showcase - Enhanced</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --accent-bg: #2a2a2a;
            --primary-text: #ffffff;
            --secondary-text: #b0b0b0;
            --accent-color: #00ff88;
            --warning-color: #ffaa00;
            --error-color: #ff4444;
            --success-color: #00ff88;
            --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --gradient-4: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --gradient-5: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --glow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            background-image:
                radial-gradient(circle at 20% 80%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(118, 75, 162, 0.1) 0%, transparent 50%);
            min-height: 100vh;
            color: var(--primary-text);
            overflow-x: hidden;
        }

        .header {
            background: var(--secondary-bg);
            padding: 20px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5rem;
            background: var(--gradient-4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 10px;
        }

        .header p {
            text-align: center;
            color: var(--secondary-text);
            font-size: 1.1rem;
        }

        .nav-links {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 16px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 24px;
            background: var(--accent-bg);
            color: var(--secondary-text);
            text-decoration: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .nav-link::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--gradient-4);
            opacity: 0.1;
            transition: left 0.3s ease;
        }

        .nav-link:hover::before {
            left: 0;
        }

        .nav-link:hover {
            color: var(--primary-text);
            background: var(--secondary-bg);
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: var(--glow);
        }

        .nav-link.active {
            background: var(--gradient-4);
            color: var(--primary-text);
            border-color: var(--accent-color);
            box-shadow: var(--glow);
        }

        .nav-link.active::before {
            display: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .visualization-section {
            background: var(--secondary-bg);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(0, 255, 136, 0.1);
        }

        .section-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            background: var(--gradient-2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-description {
            color: var(--secondary-text);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .visualization-container {
            background: var(--accent-bg);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            height: 500px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        /* Enhanced Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--secondary-text);
            font-size: 1.1rem;
            flex-direction: column;
            gap: 16px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1rem;
            color: var(--secondary-text);
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .loading-progress-bar {
            height: 100%;
            background: var(--gradient-4);
            border-radius: 2px;
            animation: progress 2s ease-in-out infinite;
        }

        @keyframes progress {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }

        /* Enhanced Error States */
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--error-color);
            font-size: 1.1rem;
            flex-direction: column;
            gap: 16px;
            text-align: center;
            padding: 20px;
        }

        .error-icon {
            font-size: 3rem;
            opacity: 0.7;
        }

        .error-message {
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .error-details {
            font-size: 0.9rem;
            color: var(--secondary-text);
            margin-bottom: 15px;
        }

        .retry-button {
            background: var(--error-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .retry-button:hover {
            background: #ff6666;
            transform: translateY(-2px);
        }

        /* Data Refresh Indicators */
        .refresh-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--accent-bg);
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            font-size: 0.8rem;
            color: var(--secondary-text);
        }

        .refresh-indicator.refreshing {
            color: var(--accent-color);
        }

        .refresh-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .last-updated {
            font-size: 0.7rem;
            color: var(--secondary-text);
        }

        /* Keyboard Shortcuts */
        .shortcuts-help {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--secondary-bg);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-size: 0.8rem;
            color: var(--secondary-text);
            z-index: 1000;
            max-width: 200px;
            display: none;
        }

        .shortcuts-help.show {
            display: block;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .shortcut-key {
            background: var(--accent-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.7rem;
        }

        /* Fallback Visualizations */
        .fallback-chart {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            flex-direction: column;
            gap: 20px;
            color: var(--secondary-text);
        }

        .fallback-icon {
            font-size: 4rem;
            opacity: 0.5;
        }

        .fallback-message {
            font-size: 1.2rem;
            text-align: center;
        }

        .fallback-suggestion {
            font-size: 0.9rem;
            color: var(--accent-color);
            text-align: center;
        }

        /* Navigation Grid Styles */
        .nav-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .nav-card {
            background: var(--accent-bg);
            border-radius: 12px;
            padding: 20px;
            text-decoration: none;
            color: var(--primary-text);
            border: 1px solid rgba(0, 255, 136, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .nav-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--gradient-4);
            transition: all 0.3s ease;
        }

        .nav-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            border-color: var(--accent-color);
        }

        .nav-card:hover::before {
            background: var(--gradient-2);
            box-shadow: 0 0 15px var(--accent-color);
        }

        .nav-icon {
            font-size: 2rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .nav-title {
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-align: center;
            color: var(--primary-text);
        }

        .nav-desc {
            font-size: 0.85rem;
            color: var(--secondary-text);
            text-align: center;
            line-height: 1.4;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .visualization-container {
                padding: 16px;
                margin-bottom: 16px;
                border-radius: 12px;
                height: 400px;
                width: 100%;
            }

            .header h1 {
                font-size: 2rem;
            }

            .header p {
                font-size: 1rem;
            }

            .nav-links {
                flex-direction: column;
                gap: 8px;
            }

            .nav-link {
                padding: 10px 16px;
                font-size: 0.9rem;
            }

            .nav-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .nav-card {
                padding: 16px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 16px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .visualization-container {
                padding: 12px;
                min-height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚀 TappMCP D3.js Visualizations - Enhanced</h1>
        <p>Interactive Data Visualizations & System Monitoring Dashboard with Advanced Features</p>

        <!-- Navigation Links -->
        <div class="nav-links">
            <a href="index-enhanced.html" class="nav-link">📊 Enhanced Main Dashboard</a>
            <a href="d3-visualizations-enhanced.html" class="nav-link active">📈 Enhanced D3.js Visualizations</a>
            <a href="index.html" class="nav-link">📋 Original Main Dashboard</a>
            <a href="d3-visualizations.html" class="nav-link">📊 Original D3.js Visualizations</a>
            <a href="test-websocket.html" class="nav-link">🔌 WebSocket Test</a>
        </div>
    </div>

    <!-- Keyboard Shortcuts Help -->
    <div class="shortcuts-help" id="shortcutsHelp">
        <h4>⌨️ Keyboard Shortcuts</h4>
        <div class="shortcut-item">
            <span>Refresh Data</span>
            <span class="shortcut-key">F5</span>
        </div>
        <div class="shortcut-item">
            <span>Toggle Help</span>
            <span class="shortcut-key">?</span>
        </div>
        <div class="shortcut-item">
            <span>Export Data</span>
            <span class="shortcut-key">Ctrl+E</span>
        </div>
        <div class="shortcut-item">
            <span>Reset Filters</span>
            <span class="shortcut-key">Ctrl+R</span>
        </div>
    </div>

    <div class="container">
        <!-- Quick Navigation Section -->
        <div class="visualization-section" style="margin-bottom: 20px;">
            <h2 class="section-title">🎯 Quick Navigation</h2>
            <div class="nav-grid">
                <a href="index-enhanced.html" class="nav-card">
                    <div class="nav-icon">📊</div>
                    <div class="nav-title">Enhanced Main Dashboard</div>
                    <div class="nav-desc">Advanced monitoring & system status</div>
                </a>
                <a href="index.html" class="nav-card">
                    <div class="nav-icon">📋</div>
                    <div class="nav-title">Original Main Dashboard</div>
                    <div class="nav-desc">Classic dashboard interface</div>
                </a>
                <a href="d3-visualizations.html" class="nav-card">
                    <div class="nav-icon">📊</div>
                    <div class="nav-title">Original D3.js Visualizations</div>
                    <div class="nav-desc">Basic D3.js charts & graphs</div>
                </a>
                <a href="test-websocket.html" class="nav-card">
                    <div class="nav-icon">🔌</div>
                    <div class="nav-title">WebSocket Test</div>
                    <div class="nav-desc">Test real-time connections</div>
                </a>
            </div>
        </div>

        <!-- Workflow Graph Section -->
        <div class="visualization-section" id="workflow-graph">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Interactive Workflow Graph
            </h2>
            <div class="section-description">
                Force-directed graph visualization showing workflow nodes, connections, and real-time status updates.
                Features zoom, pan, drag-and-drop, and interactive tooltips.
            </div>

            <div class="visualization-container">
                <div class="refresh-indicator" id="workflowRefreshIndicator">
                    <span class="refresh-spinner" style="display: none;"></span>
                    <span class="refresh-text">Last updated: <span class="last-updated" id="workflowLastUpdate">Never</span></span>
                </div>
                <div id="workflow-graph-container"></div>
            </div>
        </div>

        <!-- Performance Overlay Section -->
        <div class="visualization-section" id="performance-overlay">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Performance Monitoring Overlay
            </h2>
            <div class="section-description">
                Real-time system performance metrics including CPU usage, memory consumption, response times, and error rates.
                Features multi-metric charts, area overlays, and threshold alerts.
            </div>

            <div class="visualization-container">
                <div class="refresh-indicator" id="performanceRefreshIndicator">
                    <span class="refresh-spinner" style="display: none;"></span>
                    <span class="refresh-text">Last updated: <span class="last-updated" id="performanceLastUpdate">Never</span></span>
                </div>
                <div id="performance-chart-container"></div>
            </div>
        </div>

        <!-- Value Dashboard Section -->
        <div class="visualization-section" id="value-dashboard">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                TappMCP Value Metrics Dashboard
            </h2>
            <div class="section-description">
                Comprehensive value tracking including tokens used/saved, cost savings, time saved, bugs found, and quality scores.
                Features time-series charts, scatter plots, and interactive data exploration.
            </div>

            <div class="visualization-container">
                <div class="refresh-indicator" id="valueRefreshIndicator">
                    <span class="refresh-spinner" style="display: none;"></span>
                    <span class="refresh-text">Last updated: <span class="last-updated" id="valueLastUpdate">Never</span></span>
                </div>
                <div id="value-dashboard-container"></div>
            </div>
        </div>

        <!-- Timeline View Section -->
        <div class="visualization-section" id="timeline-view">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Event Timeline Visualization
            </h2>
            <div class="section-description">
                Gantt-style timeline showing workflow events, durations, and dependencies.
                Features interactive zoom, time range selection, and color-coded event types.
            </div>

            <div class="visualization-container">
                <div class="refresh-indicator" id="timelineRefreshIndicator">
                    <span class="refresh-spinner" style="display: none;"></span>
                    <span class="refresh-text">Last updated: <span class="last-updated" id="timelineLastUpdate">Never</span></span>
                </div>
                <div id="timeline-view-container"></div>
            </div>
        </div>
    </div>

    <script type="text/babel">
        // Enhanced Error Boundary Component
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true };
            }

            componentDidCatch(error, errorInfo) {
                this.setState({
                    error: error,
                    errorInfo: errorInfo
                });
                console.error('ErrorBoundary caught an error:', error, errorInfo);
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="error">
                            <div className="error-icon">⚠️</div>
                            <div className="error-message">Something went wrong with this visualization</div>
                            <div className="error-details">
                                {this.state.error && this.state.error.toString()}
                            </div>
                            <button
                                className="retry-button"
                                onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}
                            >
                                Try Again
                            </button>
                        </div>
                    );
                }

                return this.props.children;
            }
        }

        // Enhanced Loading Component
        const LoadingComponent = ({ message = "Loading...", progress = null }) => (
            <div className="loading">
                <div className="loading-spinner"></div>
                <div className="loading-text">{message}</div>
                {progress !== null && (
                    <div className="loading-progress">
                        <div
                            className="loading-progress-bar"
                            style={{ width: `${progress}%` }}
                        ></div>
                    </div>
                )}
            </div>
        );

        // Enhanced Error Component
        const ErrorComponent = ({ message, details, onRetry }) => (
            <div className="error">
                <div className="error-icon">❌</div>
                <div className="error-message">{message}</div>
                {details && <div className="error-details">{details}</div>}
                {onRetry && (
                    <button className="retry-button" onClick={onRetry}>
                        Retry
                    </button>
                )}
            </div>
        );

        // Fallback Visualization Component
        const FallbackVisualization = ({ type, message }) => (
            <div className="fallback-chart">
                <div className="fallback-icon">📊</div>
                <div className="fallback-message">{message || 'No data available'}</div>
                <div className="fallback-suggestion">
                    Try refreshing the data or check your connection
                </div>
            </div>
        );

        // Enhanced Data Validation
        const validateApiResponse = (data, expectedFields = []) => {
            if (!data || typeof data !== 'object') {
                throw new Error('Invalid response format');
            }

            for (const field of expectedFields) {
                if (!(field in data)) {
                    throw new Error(`Missing required field: ${field}`);
                }
            }

            return true;
        };

        // Enhanced WebSocket Manager
        class WebSocketManager {
            constructor(url, options = {}) {
                this.url = url;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
                this.reconnectDelay = options.reconnectDelay || 1000;
                this.connectionStatus = 'disconnected';
                this.listeners = new Map();
                this.connect();
            }

            connect() {
                try {
                    this.ws = new WebSocket(this.url);
                    this.connectionStatus = 'connecting';

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.connectionStatus = 'connected';
                        this.reconnectAttempts = 0;
                        this.notifyListeners('connected');
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.notifyListeners('message', data);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                            this.notifyListeners('error', error);
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket disconnected');
                        this.connectionStatus = 'disconnected';
                        this.notifyListeners('disconnected');
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.connectionStatus = 'error';
                        this.notifyListeners('error', error);
                    };

                } catch (error) {
                    console.error('Failed to connect to WebSocket:', error);
                    this.connectionStatus = 'error';
                    this.notifyListeners('error', error);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

                    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);

                    setTimeout(() => {
                        this.connect();
                    }, delay);
                }
            }

            addEventListener(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            }

            removeEventListener(event, callback) {
                if (this.listeners.has(event)) {
                    const callbacks = this.listeners.get(event);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            }

            notifyListeners(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('Error in WebSocket listener:', error);
                        }
                    });
                }
            }

            send(data) {
                if (this.ws && this.connectionStatus === 'connected') {
                    this.ws.send(JSON.stringify(data));
                }
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // Enhanced Workflow Graph Component
        const WorkflowGraph = () => {
            const svgRef = React.useRef(null);
            const [data, setData] = React.useState({ nodes: [], connections: [] });
            const [error, setError] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [lastUpdate, setLastUpdate] = React.useState(null);
            const [refreshing, setRefreshing] = React.useState(false);

            React.useEffect(() => {
                // Initial demo data
                const initialNodes = [
                    { id: "start", name: "Start", status: "completed", phase: "Initialization", progress: 100, x: 100, y: 200 },
                    { id: "process1", name: "Data Process", status: "running", phase: "Processing", progress: 65, x: 300, y: 150 },
                    { id: "process2", name: "Analysis", status: "pending", phase: "Analysis", progress: 0, x: 300, y: 250 },
                    { id: "process3", name: "Validation", status: "pending", phase: "Validation", progress: 0, x: 500, y: 200 },
                    { id: "end", name: "Complete", status: "pending", phase: "Finalization", progress: 0, x: 700, y: 200 }
                ];

                const initialConnections = [
                    { source: "start", target: "process1", type: "sequence" },
                    { source: "process1", target: "process2", type: "dependency" },
                    { source: "process1", target: "process3", type: "data-flow" },
                    { source: "process2", target: "end", type: "sequence" },
                    { source: "process3", target: "end", type: "sequence" }
                ];

                setData({ nodes: initialNodes, connections: initialConnections });
                setLoading(false);
                setLastUpdate(new Date());

                // Set up WebSocket connection
                const wsManager = new WebSocketManager('ws://localhost:8080');

                wsManager.addEventListener('message', (data) => {
                    if (data.type === 'workflow_status_update') {
                        setRefreshing(true);
                        try {
                            validateApiResponse(data, ['data']);
                            // Process workflow update
                            setLastUpdate(new Date());
                        } catch (error) {
                            setError('Invalid workflow data received');
                        } finally {
                            setRefreshing(false);
                        }
                    }
                });

                wsManager.addEventListener('error', (error) => {
                    setError('Connection error: ' + error.message);
                });

                return () => {
                    wsManager.close();
                };
            }, []);

            React.useEffect(() => {
                if (!svgRef.current || loading) {
                    console.log('WorkflowGraph: Not ready to render', { svgRef: !!svgRef.current, loading });
                    return;
                }

                try {
                    console.log('WorkflowGraph: Starting render');
                    const svg = d3.select(svgRef.current);
                    svg.selectAll("*").remove();

                    if (!data.nodes || data.nodes.length === 0) {
                        console.log('WorkflowGraph: No data available');
                        return;
                    }

                    // Create visualization
                    const containerRect = svgRef.current.getBoundingClientRect();
                    const width = containerRect.width || 800;
                    const height = containerRect.height || 400;

                    // Set SVG dimensions
                    svg.attr("width", width).attr("height", height);

                    // Set up scales
                    const xScale = d3.scaleLinear().domain([0, 1200]).range([50, width - 50]);
                    const yScale = d3.scaleLinear().domain([0, 400]).range([50, height - 50]);

                    // Create force simulation
                    const simulation = d3.forceSimulation(data.nodes)
                        .force("link", d3.forceLink(data.connections).id(d => d.id).distance(150))
                        .force("charge", d3.forceManyBody().strength(-300))
                        .force("center", d3.forceCenter(width / 2, height / 2))
                        .force("collision", d3.forceCollide().radius(50));

                    // Create main group
                    const g = svg.append("g");

                    // Add zoom behavior
                    const zoom = d3.zoom()
                        .scaleExtent([0.5, 3])
                        .on("zoom", (event) => {
                            g.attr("transform", event.transform);
                        });

                    svg.call(zoom);

                    // Draw connections
                    const connections = g.selectAll(".connection")
                        .data(data.connections || [])
                        .enter()
                        .append("line")
                        .attr("class", "connection")
                        .attr("stroke", "#00ff88")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.6);

                    // Draw nodes
                    const nodeGroups = g.selectAll(".node")
                        .data(data.nodes || [])
                        .enter()
                        .append("g")
                        .attr("class", "node");

                    // Node circles
                    nodeGroups.append("circle")
                        .attr("r", 35)
                        .attr("fill", d => {
                            const colors = {
                                completed: "#00ff88",
                                running: "#ffaa00",
                                pending: "#666666",
                                failed: "#ff4444"
                            };
                            return colors[d.status] || "#666666";
                        })
                        .attr("stroke", "#ffffff")
                        .attr("stroke-width", 2);

                    // Node labels
                    nodeGroups.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .attr("fill", "#ffffff")
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .text(d => d.name || 'Unknown');

                    // Update positions on simulation tick
                    simulation.on("tick", () => {
                        nodeGroups.attr("transform", d =>
                            `translate(${xScale(d.x)}, ${yScale(d.y)})`
                        );

                        connections
                            .attr("x1", d => {
                                const sourceNode = data.nodes.find(n => n.id === d.source);
                                return sourceNode ? xScale(sourceNode.x) : 0;
                            })
                            .attr("y1", d => {
                                const sourceNode = data.nodes.find(n => n.id === d.source);
                                return sourceNode ? yScale(sourceNode.y) : 0;
                            })
                            .attr("x2", d => {
                                const targetNode = data.nodes.find(n => n.id === d.target);
                                return targetNode ? xScale(targetNode.x) : 0;
                            })
                            .attr("y2", d => {
                                const targetNode = data.nodes.find(n => n.id === d.target);
                                return targetNode ? yScale(targetNode.y) : 0;
                            });
                    });

                    // Store simulation reference for cleanup
                    svgRef.current._simulation = simulation;

                } catch (err) {
                    setError('Failed to render workflow graph: ' + err.message);
                }
            }, [data, loading]);

            // Cleanup on unmount
            React.useEffect(() => {
                return () => {
                    if (svgRef.current && svgRef.current._simulation) {
                        svgRef.current._simulation.stop();
                    }
                };
            }, []);

            if (loading) {
                return <LoadingComponent message="Loading workflow graph..." />;
            }

            if (error) {
                return (
                    <ErrorComponent
                        message="Failed to load workflow graph"
                        details={error}
                        onRetry={() => {
                            setError(null);
                            setLoading(true);
                            // Retry logic here
                        }}
                    />
                );
            }

            if (!data.nodes || data.nodes.length === 0) {
                return <FallbackVisualization message="No workflow data available" />;
            }

            return (
                <div style={{width: "100%", height: "100%", position: "relative"}}>
                    <svg ref={svgRef} width="100%" height="100%" style={{display: "block"}}></svg>
                </div>
            );
        };

        // Enhanced Performance Chart Component
        const PerformanceChart = () => {
            const svgRef = React.useRef(null);
            const [data, setData] = React.useState([]);
            const [error, setError] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [lastUpdate, setLastUpdate] = React.useState(null);

            React.useEffect(() => {
                // Initial demo data
                const initialData = Array.from({length: 20}, (_, i) => ({
                    timestamp: Date.now() - (19 - i) * 60000,
                    memory: 60 + Math.random() * 20,
                    cpu: 20 + Math.random() * 60,
                    responseTime: 50 + Math.random() * 100,
                    errorRate: Math.random() * 0.05
                }));

                setData(initialData);
                setLoading(false);
                setLastUpdate(new Date());
            }, []);

            React.useEffect(() => {
                if (!svgRef.current || loading) return;

                try {
                    const svg = d3.select(svgRef.current);
                    svg.selectAll("*").remove();

                    if (data.length === 0) {
                        return;
                    }

                    const containerRect = svgRef.current.getBoundingClientRect();
                    const width = containerRect.width || 800;
                    const height = containerRect.height || 300;
                    const margin = { top: 20, right: 80, bottom: 40, left: 60 };

                    // Set SVG dimensions
                    svg.attr("width", width).attr("height", height);

                    // Set up scales
                    const xScale = d3.scaleTime()
                        .domain(d3.extent(data, d => d.timestamp))
                        .range([margin.left, width - margin.right]);

                    const yScale = d3.scaleLinear()
                        .domain([0, 100])
                        .range([height - margin.bottom, margin.top]);

                    // Create main group
                    const g = svg.append("g");

                    // Add axes
                    g.append("g")
                        .attr("transform", `translate(0,${height - margin.bottom})`)
                        .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")));

                    g.append("g")
                        .attr("transform", `translate(${margin.left},0)`)
                        .call(d3.axisLeft(yScale));

                    // CPU line
                    const cpuLine = d3.line()
                        .x(d => xScale(d.timestamp))
                        .y(d => yScale(d.cpu))
                        .curve(d3.curveMonotoneX);

                    g.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", "#ff6b6b")
                        .attr("stroke-width", 2)
                        .attr("d", cpuLine);

                    // Memory line
                    const memoryLine = d3.line()
                        .x(d => xScale(d.timestamp))
                        .y(d => yScale(d.memory))
                        .curve(d3.curveMonotoneX);

                    g.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", "#4ecdc4")
                        .attr("stroke-width", 2)
                        .attr("d", memoryLine);

                } catch (err) {
                    setError('Failed to render performance chart: ' + err.message);
                }
            }, [data, loading]);

            if (loading) {
                return <LoadingComponent message="Loading performance data..." />;
            }

            if (error) {
                return (
                    <ErrorComponent
                        message="Failed to load performance data"
                        details={error}
                        onRetry={() => {
                            setError(null);
                            setLoading(true);
                        }}
                    />
                );
            }

            if (data.length === 0) {
                return <FallbackVisualization message="No performance data available" />;
            }

            return <svg ref={svgRef} width="100%" height="300" style={{border: "1px solid #333"}}></svg>;
        };

        // Keyboard Shortcuts Handler
        React.useEffect(() => {
            const handleKeyPress = (event) => {
                if (event.key === '?' || event.key === 'F1') {
                    event.preventDefault();
                    const help = document.getElementById('shortcutsHelp');
                    help.classList.toggle('show');
                } else if (event.key === 'F5') {
                    event.preventDefault();
                    window.location.reload();
                } else if (event.ctrlKey && event.key === 'e') {
                    event.preventDefault();
                    // Export data functionality
                    console.log('Export data triggered');
                } else if (event.ctrlKey && event.key === 'r') {
                    event.preventDefault();
                    // Reset filters functionality
                    console.log('Reset filters triggered');
                }
            };

            document.addEventListener('keydown', handleKeyPress);
            return () => document.removeEventListener('keydown', handleKeyPress);
        }, []);

        // Main App Component
        const App = () => {
            return (
                <div>
                    <ErrorBoundary>
                        <WorkflowGraph />
                    </ErrorBoundary>
                    <ErrorBoundary>
                        <PerformanceChart />
                    </ErrorBoundary>
                </div>
            );
        };

        // Render the app components
        const workflowContainer = document.getElementById('workflow-graph-container');
        const performanceContainer = document.getElementById('performance-chart-container');

        if (workflowContainer) {
            const root = ReactDOM.createRoot(workflowContainer);
            root.render(<WorkflowGraph />);
        }

        if (performanceContainer) {
            const root = ReactDOM.createRoot(performanceContainer);
            root.render(<PerformanceChart />);
        }
    </script>
</body>
</html>
