<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ TappMCP D3.js Visualizations Showcase</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --accent-bg: #2a2a2a;
            --primary-text: #ffffff;
            --secondary-text: #b0b0b0;
            --accent-color: #00ff88;
            --warning-color: #ffaa00;
            --error-color: #ff4444;
            --success-color: #00ff88;
            --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --gradient-4: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --gradient-5: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --glow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            background-image:
                radial-gradient(circle at 20% 80%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(118, 75, 162, 0.1) 0%, transparent 50%);
            min-height: 100vh;
            color: var(--primary-text);
            overflow-x: hidden;
        }

        .header {
            background: var(--secondary-bg);
            padding: 20px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5rem;
            background: var(--gradient-4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 10px;
        }

        .header p {
            text-align: center;
            color: var(--secondary-text);
            font-size: 1.1rem;
        }

        .nav-links {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 16px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            padding: 12px 24px;
            background: var(--accent-bg);
            color: var(--secondary-text);
            text-decoration: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .nav-link::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--gradient-4);
            opacity: 0.1;
            transition: left 0.3s ease;
        }

        .nav-link:hover::before {
            left: 0;
        }

        .nav-link:hover {
            color: var(--primary-text);
            background: var(--secondary-bg);
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: var(--glow);
        }

        .nav-link.active {
            background: var(--gradient-4);
            color: var(--primary-text);
            border-color: var(--accent-color);
            box-shadow: var(--glow);
        }

        .nav-link.active::before {
            display: none;
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .nav-btn {
            background: var(--gradient-1);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .visualization-section {
            background: var(--secondary-bg);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(0, 255, 136, 0.1);
        }

        .section-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            background: var(--gradient-2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-description {
            color: var(--secondary-text);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .visualization-container {
            background: var(--accent-bg);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workflow-graph {
            width: 100%;
            height: 600px;
        }

        .performance-chart {
            width: 100%;
            height: 400px;
        }

        .value-dashboard {
            width: 100%;
            height: 500px;
        }

        .timeline-view {
            width: 100%;
            height: 400px;
        }

        .demo-data-notice {
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid var(--warning-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: var(--warning-color);
        }

        .demo-data-notice h4 {
            margin-bottom: 10px;
            color: var(--warning-color);
        }

        .demo-data-notice p {
            margin-bottom: 8px;
        }

        .demo-data-notice code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ready { background: var(--success-color); }
        .status-demo { background: var(--warning-color); }
        .status-pending { background: var(--error-color); }

        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-item {
            background: var(--accent-bg);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 136, 0.1);
        }

        .feature-item h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
        }

        .feature-item ul {
            list-style: none;
            padding: 0;
        }

        .feature-item li {
            padding: 5px 0;
            color: var(--secondary-text);
        }

        .feature-item li:before {
            content: "‚úì ";
            color: var(--success-color);
            font-weight: bold;
        }

        .filter-controls {
            background: var(--accent-bg);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .filter-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-label {
            color: var(--secondary-text);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .filter-input {
            background: var(--secondary-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--primary-text);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
        }

        .filter-select {
            background: var(--secondary-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--primary-text);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
        }

        .filter-button {
            background: var(--gradient-1);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .filter-button:hover {
            transform: translateY(-1px);
            box-shadow: var(--glow);
        }

        .filter-button.secondary {
            background: var(--accent-bg);
            color: var(--secondary-text);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .filter-button.secondary:hover {
            background: var(--secondary-bg);
            color: var(--primary-text);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .nav-buttons {
                flex-direction: column;
                align-items: center;
            }

            .container {
                padding: 10px;
            }

            .visualization-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ TappMCP D3.js Visualizations</h1>
        <p>Interactive Data Visualizations & System Monitoring Dashboard</p>
        <!-- Navigation Links -->
        <div class="nav-links">
            <a href="index.html" class="nav-link">üìä Main Dashboard</a>
            <a href="d3-visualizations.html" class="nav-link active">üìà D3.js Visualizations</a>
        </div>

        <div class="nav-buttons">
            <a href="#workflow-graph" class="nav-btn">Workflow Graph</a>
            <a href="#performance-overlay" class="nav-btn">Performance Overlay</a>
            <a href="#value-dashboard" class="nav-btn">Value Dashboard</a>
            <a href="#timeline-view" class="nav-btn">Timeline View</a>
        </div>
    </div>

    <div class="container">
        <!-- Workflow Graph Section -->
        <div class="visualization-section" id="workflow-graph">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Interactive Workflow Graph
            </h2>
            <div class="section-description">
                Force-directed graph visualization showing workflow nodes, connections, and real-time status updates.
                Features zoom, pan, drag-and-drop, and interactive tooltips.
            </div>
            <div class="demo-data-notice" id="workflow-notice">
                <h4>üìä <span id="workflow-status">Demo Data Mode</span></h4>
                <p id="workflow-description">This visualization is currently showing simulated workflow data.</p>
                <p>Current features: <code>Force simulation</code>, <code>Zoom & Pan</code>, <code>Drag & Drop</code>, <code>Status colors</code></p>
                <p id="workflow-last-update" style="font-size: 0.9em; opacity: 0.7;"></p>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-row">
                    <div class="filter-group">
                        <label class="filter-label">Status Filter</label>
                        <select class="filter-select" id="workflow-status-filter">
                            <option value="all">All Statuses</option>
                            <option value="completed">Completed</option>
                            <option value="running">Running</option>
                            <option value="pending">Pending</option>
                            <option value="failed">Failed</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Phase Filter</label>
                        <select class="filter-select" id="workflow-phase-filter">
                            <option value="all">All Phases</option>
                            <option value="Initialization">Initialization</option>
                            <option value="Processing">Processing</option>
                            <option value="Analysis">Analysis</option>
                            <option value="Validation">Validation</option>
                            <option value="Finalization">Finalization</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Layout</label>
                        <select class="filter-select" id="workflow-layout">
                            <option value="force">Force Directed</option>
                            <option value="grid">Grid Layout</option>
                            <option value="hierarchical">Hierarchical</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="filter-button" onclick="resetWorkflowFilters()">Reset</button>
                        <button class="filter-button secondary" onclick="exportWorkflowData()">Export</button>
                    </div>
                </div>
            </div>
            <div class="visualization-container">
                <div id="workflow-graph-container"></div>
            </div>
        </div>

        <!-- Performance Overlay Section -->
        <div class="visualization-section" id="performance-overlay">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Performance Monitoring Overlay
            </h2>
            <div class="section-description">
                Real-time system performance metrics including CPU usage, memory consumption, response times, and error rates.
                Features multi-metric charts, area overlays, and threshold alerts.
            </div>
            <div class="demo-data-notice" id="performance-notice">
                <h4>üìä <span id="performance-status">Demo Data Mode</span></h4>
                <p id="performance-description">This visualization is currently showing simulated performance data.</p>
                <p>Current features: <code>Multi-line charts</code>, <code>Area overlays</code>, <code>Interactive legends</code>, <code>Alert indicators</code></p>
                <p id="performance-last-update" style="font-size: 0.9em; opacity: 0.7;"></p>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-row">
                    <div class="filter-group">
                        <label class="filter-label">Time Range</label>
                        <select class="filter-select" id="performance-time-range">
                            <option value="5m">Last 5 Minutes</option>
                            <option value="15m">Last 15 Minutes</option>
                            <option value="1h">Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h">Last 24 Hours</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Metrics</label>
                        <select class="filter-select" id="performance-metrics" multiple>
                            <option value="cpu" selected>CPU Usage</option>
                            <option value="memory" selected>Memory Usage</option>
                            <option value="responseTime">Response Time</option>
                            <option value="errorRate">Error Rate</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Chart Type</label>
                        <select class="filter-select" id="performance-chart-type">
                            <option value="line">Line Chart</option>
                            <option value="area">Area Chart</option>
                            <option value="bar">Bar Chart</option>
                            <option value="scatter">Scatter Plot</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="filter-button" onclick="resetPerformanceFilters()">Reset</button>
                        <button class="filter-button secondary" onclick="exportPerformanceData()">Export</button>
                    </div>
                </div>
            </div>
            <div class="visualization-container">
                <div id="performance-chart-container"></div>
            </div>
        </div>

        <!-- Value Dashboard Section -->
        <div class="visualization-section" id="value-dashboard">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                TappMCP Value Metrics Dashboard
            </h2>
            <div class="section-description">
                Comprehensive value tracking including tokens used/saved, cost savings, time saved, bugs found, and quality scores.
                Features time-series charts, scatter plots, and interactive data exploration.
            </div>
            <div class="demo-data-notice" id="value-notice">
                <h4>üìä <span id="value-status">Demo Data Mode</span></h4>
                <p id="value-description">This visualization is currently showing simulated value metrics data.</p>
                <p>Current features: <code>Time-series charts</code>, <code>Scatter plots</code>, <code>Area charts</code>, <code>Interactive tooltips</code></p>
                <p id="value-last-update" style="font-size: 0.9em; opacity: 0.7;"></p>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-row">
                    <div class="filter-group">
                        <label class="filter-label">Time Range</label>
                        <select class="filter-select" id="value-time-range">
                            <option value="15m">Last 15 Minutes</option>
                            <option value="1h" selected>Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h">Last 24 Hours</option>
                            <option value="7d">Last 7 Days</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Metrics</label>
                        <select class="filter-select" id="value-metrics">
                            <option value="all" selected>All Metrics</option>
                            <option value="tokens">Tokens Only</option>
                            <option value="cost">Cost Savings</option>
                            <option value="quality">Quality Scores</option>
                            <option value="bugs">Bug Detection</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Chart Type</label>
                        <select class="filter-select" id="value-chart-type">
                            <option value="line" selected>Line Chart</option>
                            <option value="area">Area Chart</option>
                            <option value="scatter">Scatter Plot</option>
                            <option value="bar">Bar Chart</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="filter-button" onclick="resetValueFilters()">Reset</button>
                        <button class="filter-button secondary" onclick="exportValueData()">Export</button>
                    </div>
                </div>
            </div>
            <div class="visualization-container">
                <div id="value-dashboard-container"></div>
            </div>
        </div>

        <!-- Timeline View Section -->
        <div class="visualization-section" id="timeline-view">
            <h2 class="section-title">
                <span class="status-indicator status-demo"></span>
                Event Timeline Visualization
            </h2>
            <div class="section-description">
                Gantt-style timeline showing workflow events, durations, and dependencies.
                Features interactive zoom, time range selection, and color-coded event types.
            </div>
            <div class="demo-data-notice" id="timeline-notice">
                <h4>üìä <span id="timeline-status">Demo Data Mode</span></h4>
                <p id="timeline-description">This visualization is currently showing simulated timeline data.</p>
                <p>Current features: <code>Gantt-style timeline</code>, <code>Interactive zoom</code>, <code>Event filtering</code>, <code>Duration visualization</code></p>
                <p id="timeline-last-update" style="font-size: 0.9em; opacity: 0.7;"></p>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-row">
                    <div class="filter-group">
                        <label class="filter-label">Time Range</label>
                        <select class="filter-select" id="timeline-time-range">
                            <option value="1h">Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h" selected>Last 24 Hours</option>
                            <option value="7d">Last 7 Days</option>
                            <option value="30d">Last 30 Days</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Event Types</label>
                        <select class="filter-select" id="timeline-event-types">
                            <option value="all" selected>All Events</option>
                            <option value="data">Data Events</option>
                            <option value="process">Process Events</option>
                            <option value="analysis">Analysis Events</option>
                            <option value="validation">Validation Events</option>
                            <option value="report">Report Events</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">View Type</label>
                        <select class="filter-select" id="timeline-view-type">
                            <option value="gantt" selected>Gantt Timeline</option>
                            <option value="list">List View</option>
                            <option value="calendar">Calendar View</option>
                            <option value="network">Network View</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="filter-button" onclick="resetTimelineFilters()">Reset</button>
                        <button class="filter-button secondary" onclick="exportTimelineData()">Export</button>
                    </div>
                </div>
            </div>
            <div class="visualization-container">
                <div id="timeline-view-container"></div>
            </div>
        </div>

        <!-- Features Overview -->
        <div class="visualization-section">
            <h2 class="section-title">
                <span class="status-indicator status-ready"></span>
                D3.js Features & Capabilities
            </h2>
            <div class="section-description">
                The TappMCP project includes a comprehensive set of D3.js visualizations with advanced features and interactions.
            </div>
            <div class="feature-list">
                <div class="feature-item">
                    <h4>üéØ Interactive Charts</h4>
                    <ul>
                        <li>Force-directed graphs</li>
                        <li>Time-series line charts</li>
                        <li>Area charts with gradients</li>
                        <li>Scatter plots with tooltips</li>
                        <li>Gantt-style timelines</li>
                    </ul>
                </div>
                <div class="feature-item">
                    <h4>üîÑ User Interactions</h4>
                    <ul>
                        <li>Zoom and pan controls</li>
                        <li>Drag and drop nodes</li>
                        <li>Hover tooltips</li>
                        <li>Click to drill down</li>
                        <li>Legend toggles</li>
                    </ul>
                </div>
                <div class="feature-item">
                    <h4>üìä Data Visualization</h4>
                    <ul>
                        <li>Real-time data binding</li>
                        <li>Dynamic scaling</li>
                        <li>Color-coded status</li>
                        <li>Threshold indicators</li>
                        <li>Multi-metric overlays</li>
                    </ul>
                </div>
                <div class="feature-item">
                    <h4>‚ö° Performance</h4>
                    <ul>
                        <li>Efficient data joins</li>
                        <li>Smooth transitions</li>
                        <li>Optimized rendering</li>
                        <li>Memory management</li>
                        <li>Responsive design</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script type="text/babel">
        // Global data store for live metrics
        const LiveDataStore = {
            performanceMetrics: [],
            workflowData: { nodes: [], connections: [] },
            valueMetrics: [],
            timelineEvents: [],
            isConnected: false,
            lastUpdate: null
        };

        // WebSocket connection for live data
        let ws = null;
        const connectWebSocket = () => {
            try {
                ws = new WebSocket('ws://localhost:3000');

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    LiveDataStore.isConnected = true;
                    updateConnectionStatus();
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        LiveDataStore.lastUpdate = Date.now();

                        if (data.type === 'performance_metrics') {
                            LiveDataStore.performanceMetrics.push({
                                timestamp: data.timestamp,
                                memory: data.data.memoryUsage.heapUsed / 1024 / 1024, // Convert to MB
                                cpu: data.data.cpuUsage,
                                responseTime: data.data.responseTime,
                                errorRate: data.data.errorRate * 100, // Convert to percentage
                                tokenCount: data.data.tokenCount,
                                totalTokensProcessed: data.data.totalTokensProcessed,
                                hourlyAverageTokens: data.data.hourlyAverageTokens
                            });

                            // Keep only last 50 data points
                            if (LiveDataStore.performanceMetrics.length > 50) {
                                LiveDataStore.performanceMetrics = LiveDataStore.performanceMetrics.slice(-50);
                            }

                            // Update value metrics
                            LiveDataStore.valueMetrics.push({
                                timestamp: data.timestamp,
                                totalTokensUsed: data.data.tokenCount,
                                totalTokensSaved: Math.floor(data.data.tokenCount * 0.3), // Simulate 30% savings
                                totalBugsFound: Math.floor(Math.random() * 3),
                                totalCostSavings: data.data.tokenCount * 0.001, // Simulate cost savings
                                averageQualityScore: 70 + Math.random() * 30,
                                context7CacheHitRate: data.data.cacheHitRate * 100
                            });

                            if (LiveDataStore.valueMetrics.length > 30) {
                                LiveDataStore.valueMetrics = LiveDataStore.valueMetrics.slice(-30);
                            }
                        }

                        if (data.type === 'workflow_status_update') {
                            // Update workflow data
                            const existingNodeIndex = LiveDataStore.workflowData.nodes.findIndex(n => n.id === data.workflowId);
                            if (existingNodeIndex >= 0) {
                                LiveDataStore.workflowData.nodes[existingNodeIndex] = {
                                    ...LiveDataStore.workflowData.nodes[existingNodeIndex],
                                    status: data.status,
                                    progress: data.progress,
                                    phase: data.phase
                                };
                            } else {
                                LiveDataStore.workflowData.nodes.push({
                                    id: data.workflowId,
                                    name: data.name || `Workflow ${data.workflowId}`,
                                    status: data.status,
                                    progress: data.progress,
                                    phase: data.phase,
                                    x: Math.random() * 600 + 100,
                                    y: Math.random() * 300 + 100
                                });
                            }
                        }

                    } catch (error) {
                        console.error('Error parsing WebSocket data:', error);
                    }
                };

                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    LiveDataStore.isConnected = false;
                    updateConnectionStatus();
                    // Attempt to reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    LiveDataStore.isConnected = false;
                    updateConnectionStatus();
                };

            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                LiveDataStore.isConnected = false;
                updateConnectionStatus();
            }
        };

        // Update connection status indicator
        const updateConnectionStatus = () => {
            const statusElements = document.querySelectorAll('.status-indicator');
            statusElements.forEach(el => {
                if (LiveDataStore.isConnected) {
                    el.className = 'status-indicator status-ready';
                    el.title = 'Connected to live data';
                } else {
                    el.className = 'status-indicator status-demo';
                    el.title = 'Demo data mode - WebSocket disconnected';
                }
            });

            // Update notice sections
            const updateNotice = (id, status, description, lastUpdate) => {
                const statusEl = document.getElementById(`${id}-status`);
                const descEl = document.getElementById(`${id}-description`);
                const updateEl = document.getElementById(`${id}-last-update`);

                if (statusEl) statusEl.textContent = status;
                if (descEl) descEl.textContent = description;
                if (updateEl && lastUpdate) {
                    updateEl.textContent = `Last update: ${new Date(lastUpdate).toLocaleTimeString()}`;
                }
            };

            if (LiveDataStore.isConnected) {
                updateNotice('workflow', 'Live Data Mode', 'Connected to live workflow data stream', LiveDataStore.lastUpdate);
                updateNotice('performance', 'Live Data Mode', 'Connected to live performance metrics', LiveDataStore.lastUpdate);
                updateNotice('value', 'Live Data Mode', 'Connected to live token tracking data', LiveDataStore.lastUpdate);
                updateNotice('timeline', 'Live Data Mode', 'Connected to live event timeline data', LiveDataStore.lastUpdate);
            } else {
                updateNotice('workflow', 'Demo Data Mode', 'This visualization is currently showing simulated workflow data.');
                updateNotice('performance', 'Demo Data Mode', 'This visualization is currently showing simulated performance data.');
                updateNotice('value', 'Demo Data Mode', 'This visualization is currently showing simulated value metrics data.');
                updateNotice('timeline', 'Demo Data Mode', 'This visualization is currently showing simulated timeline data.');
            }
        };

        // Initialize WebSocket connection
        connectWebSocket();

        // Filter Functions
        const resetWorkflowFilters = () => {
            document.getElementById('workflow-status-filter').value = 'all';
            document.getElementById('workflow-phase-filter').value = 'all';
            document.getElementById('workflow-layout').value = 'force';
            // Trigger workflow graph update
            if (window.workflowGraphRef) {
                window.workflowGraphRef.updateFilters();
            }
        };

        const exportWorkflowData = () => {
            const data = LiveDataStore.workflowData;
            const csv = convertToCSV(data.nodes);
            downloadCSV(csv, 'workflow-data.csv');
        };

        const resetPerformanceFilters = () => {
            document.getElementById('performance-time-range').value = '15m';
            document.getElementById('performance-chart-type').value = 'line';
            // Reset metrics selection
            const metricsSelect = document.getElementById('performance-metrics');
            Array.from(metricsSelect.options).forEach(option => {
                option.selected = ['cpu', 'memory'].includes(option.value);
            });
            // Trigger performance chart update
            if (window.performanceChartRef) {
                window.performanceChartRef.updateFilters();
            }
        };

        const exportPerformanceData = () => {
            const data = LiveDataStore.performanceMetrics;
            const csv = convertToCSV(data);
            downloadCSV(csv, 'performance-data.csv');
        };

        const resetValueFilters = () => {
            document.getElementById('value-time-range').value = '1h';
            document.getElementById('value-metrics').value = 'all';
            document.getElementById('value-chart-type').value = 'line';
            // Trigger value dashboard update
            if (window.valueDashboardRef) {
                window.valueDashboardRef.updateFilters();
            }
        };

        const exportValueData = () => {
            const data = LiveDataStore.valueMetrics;
            const csv = convertToCSV(data);
            downloadCSV(csv, 'value-data.csv');
        };

        const resetTimelineFilters = () => {
            document.getElementById('timeline-time-range').value = '24h';
            document.getElementById('timeline-event-types').value = 'all';
            document.getElementById('timeline-view-type').value = 'gantt';
            // Trigger timeline update
            if (window.timelineViewRef) {
                window.timelineViewRef.updateFilters();
            }
        };

        const exportTimelineData = () => {
            const data = LiveDataStore.timelineEvents;
            const csv = convertToCSV(data);
            downloadCSV(csv, 'timeline-data.csv');
        };

        // Utility Functions
        const convertToCSV = (data) => {
            if (!data || data.length === 0) return '';

            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => {
                    const value = row[header];
                    return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
                }).join(','))
            ].join('\n');

            return csvContent;
        };

        const downloadCSV = (csvContent, filename) => {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Workflow Graph Component
        const WorkflowGraph = () => {
            const svgRef = React.useRef(null);
            const [data, setData] = React.useState({ nodes: [], connections: [] });
            const [error, setError] = React.useState(null);
            const [loading, setLoading] = React.useState(true);

            React.useEffect(() => {
                // Initial demo data
                const initialNodes = [
                    { id: "start", name: "Start", status: "completed", phase: "Initialization", progress: 100, x: 100, y: 200 },
                    { id: "process1", name: "Data Processing", status: "running", phase: "Processing", progress: 65, x: 300, y: 150 },
                    { id: "process2", name: "Analysis", status: "pending", phase: "Analysis", progress: 0, x: 300, y: 250 },
                    { id: "process3", name: "Validation", status: "pending", phase: "Validation", progress: 0, x: 500, y: 200 },
                    { id: "end", name: "Complete", status: "pending", phase: "Finalization", progress: 0, x: 700, y: 200 }
                ];

                const initialConnections = [
                    { source: "start", target: "process1", type: "sequence" },
                    { source: "process1", target: "process2", type: "dependency" },
                    { source: "process1", target: "process3", type: "data-flow" },
                    { source: "process2", target: "end", type: "sequence" },
                    { source: "process3", target: "end", type: "sequence" }
                ];

                setData({ nodes: initialNodes, connections: initialConnections });

                // Update data every 2 seconds
                const interval = setInterval(() => {
                    if (LiveDataStore.workflowData.nodes.length > 0) {
                        setData(LiveDataStore.workflowData);
                    }
                }, 2000);

                return () => clearInterval(interval);
            }, []);

            React.useEffect(() => {
                console.log('WorkflowGraph useEffect triggered', {
                    hasSvgRef: !!svgRef.current,
                    dataLength: data.nodes ? data.nodes.length : 0,
                    data: data,
                    dataType: typeof data,
                    hasNodes: !!data.nodes,
                    hasConnections: !!data.connections
                });

                if (!svgRef.current || !data.nodes || data.nodes.length === 0) {
                    console.log('WorkflowGraph: No svg ref or no data, setting loading false');
                    setLoading(false);
                    return;
                }

                try {
                    setError(null);
                    setLoading(false);
                    console.log('WorkflowGraph: Starting D3 rendering');

                    const svg = d3.select(svgRef.current);
                    svg.selectAll("*").remove();

                const width = 800;
                const height = 400;

                // Set up scales
                const xScale = d3.scaleLinear().domain([0, 800]).range([50, width - 50]);
                const yScale = d3.scaleLinear().domain([0, 400]).range([50, height - 50]);

                // Create main group
                const g = svg.append("g");

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 3])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    });

                svg.call(zoom);

                // Draw connections
                const connections = g.selectAll(".connection")
                    .data(data.connections);

                connections.exit().remove();

                const connectionsEnter = connections.enter()
                    .append("line")
                    .attr("class", "connection");

                connectionsEnter.merge(connections)
                    .attr("x1", d => {
                        const sourceNode = data.nodes.find(n => n.id === d.source);
                        return xScale(sourceNode.x / 800 * 700 + 50);
                    })
                    .attr("y1", d => {
                        const sourceNode = data.nodes.find(n => n.id === d.source);
                        return yScale(sourceNode.y / 400 * 300 + 50);
                    })
                    .attr("x2", d => {
                        const targetNode = data.nodes.find(n => n.id === d.target);
                        return xScale(targetNode.x / 800 * 700 + 50);
                    })
                    .attr("y2", d => {
                        const targetNode = data.nodes.find(n => n.id === d.target);
                        return yScale(targetNode.y / 400 * 300 + 50);
                    })
                    .attr("stroke", "#00ff88")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6);

                // Draw nodes
                const nodeGroups = g.selectAll(".node")
                    .data(data.nodes);

                nodeGroups.exit().remove();

                const nodeGroupsEnter = nodeGroups.enter()
                    .append("g")
                    .attr("class", "node");

                const nodeGroupsUpdate = nodeGroupsEnter.merge(nodeGroups)
                    .attr("transform", d => `translate(${xScale(d.x / 800 * 700 + 50)}, ${yScale(d.y / 400 * 300 + 50)})`);

                // Node circles
                const circles = nodeGroupsUpdate.selectAll("circle.node-circle")
                    .data(d => [d]);

                circles.exit().remove();

                const circlesEnter = circles.enter()
                    .append("circle")
                    .attr("class", "node-circle");

                circlesEnter.merge(circles)
                    .attr("r", 30)
                    .attr("fill", d => {
                        const colors = {
                            completed: "#00ff88",
                            running: "#ffaa00",
                            pending: "#666666",
                            failed: "#ff4444"
                        };
                        return colors[d.status] || "#666666";
                    })
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 2);

                // Node labels
                const labels = nodeGroupsUpdate.selectAll("text.node-label")
                    .data(d => [d]);

                labels.exit().remove();

                const labelsEnter = labels.enter()
                    .append("text")
                    .attr("class", "node-label")
                    .attr("text-anchor", "middle")
                    .attr("dy", "0.35em")
                    .attr("fill", "#ffffff")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold");

                labelsEnter.merge(labels)
                    .text(d => d.name || 'Unknown');

                // Progress rings
                const progressRings = nodeGroupsUpdate.selectAll("circle.progress-ring")
                    .data(d => [d]);

                progressRings.exit().remove();

                const progressRingsEnter = progressRings.enter()
                    .append("circle")
                    .attr("class", "progress-ring");

                progressRingsEnter.merge(progressRings)
                    .attr("r", 35)
                    .attr("fill", "none")
                    .attr("stroke", "#00ff88")
                    .attr("stroke-width", 3)
                    .attr("opacity", 0.3)
                    .attr("stroke-dasharray", d => `${2 * Math.PI * 35}`)
                    .attr("stroke-dashoffset", d => `${2 * Math.PI * 35 * (1 - d.progress / 100)}`);

                } catch (err) {
                    console.error('Error rendering workflow graph:', err);
                    setError('Failed to render workflow graph. Please try refreshing the page.');
                }
            }, [data]);

            // Store reference for filter updates
            React.useEffect(() => {
                window.workflowGraphRef = {
                    updateFilters: () => {
                        // Filter logic would go here
                        console.log('Updating workflow filters');
                    }
                };
            }, []);

            if (loading) {
                return (
                    <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '400px', color: '#b0b0b0'}}>
                        <div>Loading workflow graph...</div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '400px', color: '#ff4444', flexDirection: 'column', gap: '10px'}}>
                        <div>‚ö†Ô∏è {error}</div>
                        <button onClick={() => window.location.reload()} style={{padding: '8px 16px', background: '#00ff88', color: '#000', border: 'none', borderRadius: '4px', cursor: 'pointer'}}>
                            Refresh Page
                        </button>
                    </div>
                );
            }

            return (
                <div style={{width: "100%", height: "400px", border: "1px solid #333", position: "relative"}}>
                    <svg ref={svgRef} width="100%" height="100%" style={{display: "block"}}></svg>
                </div>
            );
        };

        // Performance Chart Component
        const PerformanceChart = () => {
            const svgRef = React.useRef(null);
            const [data, setData] = React.useState([]);

            React.useEffect(() => {
                // Initial demo data
                const initialData = Array.from({length: 20}, (_, i) => ({
                    timestamp: Date.now() - (19 - i) * 60000,
                    memory: 60 + Math.random() * 20,
                    cpu: 20 + Math.random() * 60,
                    responseTime: 50 + Math.random() * 100,
                    errorRate: Math.random() * 0.05
                }));
                setData(initialData);

                // Update data every 2 seconds
                const interval = setInterval(() => {
                    if (LiveDataStore.performanceMetrics.length > 0) {
                        setData(LiveDataStore.performanceMetrics);
                    }
                }, 2000);

                return () => clearInterval(interval);
            }, []);

            React.useEffect(() => {
                console.log('PerformanceChart useEffect triggered', {
                    hasSvgRef: !!svgRef.current,
                    dataLength: data.length,
                    data: data
                });

                if (!svgRef.current || data.length === 0) {
                    console.log('PerformanceChart: No svg ref or no data');
                    return;
                }

                console.log('PerformanceChart: Starting D3 rendering');
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                const width = 800;
                const height = 300;
                const margin = { top: 20, right: 80, bottom: 40, left: 60 };

                // Set up scales
                const xScale = d3.scaleTime()
                    .domain(d3.extent(data, d => d.timestamp))
                    .range([margin.left, width - margin.right]);

                const yScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height - margin.bottom, margin.top]);

                // Create main group
                const g = svg.append("g");

                // Add axes
                g.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")));

                g.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(yScale));

                // Add axis labels
                g.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - margin.left)
                    .attr("x", 0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .attr("fill", "#b0b0b0")
                    .text("Percentage (%)");

                // CPU line
                const cpuLine = d3.line()
                    .x(d => xScale(d.timestamp))
                    .y(d => yScale(d.cpu))
                    .curve(d3.curveMonotoneX);

                const cpuPath = g.selectAll(".cpu-line")
                    .data([data]);

                cpuPath.exit().remove();

                const cpuPathEnter = cpuPath.enter()
                    .append("path")
                    .attr("class", "cpu-line");

                cpuPathEnter.merge(cpuPath)
                    .attr("fill", "none")
                    .attr("stroke", "#ff6b6b")
                    .attr("stroke-width", 2)
                    .attr("d", cpuLine);

                // Memory line
                const memoryLine = d3.line()
                    .x(d => xScale(d.timestamp))
                    .y(d => yScale(d.memory))
                    .curve(d3.curveMonotoneX);

                const memoryPath = g.selectAll(".memory-line")
                    .data([data]);

                memoryPath.exit().remove();

                const memoryPathEnter = memoryPath.enter()
                    .append("path")
                    .attr("class", "memory-line");

                memoryPathEnter.merge(memoryPath)
                    .attr("fill", "none")
                    .attr("stroke", "#4ecdc4")
                    .attr("stroke-width", 2)
                    .attr("d", memoryLine);

                // Legend
                const legend = g.append("g")
                    .attr("transform", `translate(${width - margin.right - 100}, ${margin.top})`);

                legend.append("line")
                    .attr("x1", 0).attr("x2", 20)
                    .attr("y1", 0).attr("y2", 0)
                    .attr("stroke", "#ff6b6b")
                    .attr("stroke-width", 2);

                legend.append("text")
                    .attr("x", 25).attr("y", 0)
                    .attr("dy", "0.35em")
                    .attr("fill", "#b0b0b0")
                    .text("CPU Usage");

                legend.append("line")
                    .attr("x1", 0).attr("x2", 20)
                    .attr("y1", 20).attr("y2", 20)
                    .attr("stroke", "#4ecdc4")
                    .attr("stroke-width", 2);

                legend.append("text")
                    .attr("x", 25).attr("y", 20)
                    .attr("dy", "0.35em")
                    .attr("fill", "#b0b0b0")
                    .text("Memory Usage");

            }, []);

            return <svg ref={svgRef} width="100%" height="300" style={{border: "1px solid #333"}}></svg>;
        };

        // Value Dashboard Component
        const ValueDashboard = () => {
            const svgRef = React.useRef(null);
            const [data, setData] = React.useState([]);

            React.useEffect(() => {
                // Initial demo data
                const initialData = Array.from({length: 15}, (_, i) => ({
                    timestamp: Date.now() - (14 - i) * 300000, // 5 minute intervals
                    totalTokensUsed: 1000 + Math.random() * 2000,
                    totalTokensSaved: 200 + Math.random() * 800,
                    totalBugsFound: Math.floor(Math.random() * 10),
                    totalCostSavings: 50 + Math.random() * 200,
                    averageQualityScore: 70 + Math.random() * 30
                }));
                setData(initialData);

                // Update data every 2 seconds
                const interval = setInterval(() => {
                    if (LiveDataStore.valueMetrics.length > 0) {
                        setData(LiveDataStore.valueMetrics);
                    }
                }, 2000);

                return () => clearInterval(interval);
            }, []);

            React.useEffect(() => {
                if (!svgRef.current || data.length === 0) return;

                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                const width = 800;
                const height = 400;
                const margin = { top: 20, right: 80, bottom: 40, left: 60 };

                // Set up scales
                const xScale = d3.scaleTime()
                    .domain(d3.extent(data, d => d.timestamp))
                    .range([margin.left, width - margin.right]);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.totalTokensUsed)])
                    .range([height - margin.bottom, margin.top]);

                // Create main group
                const g = svg.append("g");

                // Add axes
                g.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")));

                g.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(yScale));

                // Tokens used area
                const area = d3.area()
                    .x(d => xScale(d.timestamp))
                    .y0(height - margin.bottom)
                    .y1(d => yScale(d.totalTokensUsed))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("fill", "url(#gradient1)")
                    .attr("d", area);

                // Tokens used line
                const line = d3.line()
                    .x(d => xScale(d.timestamp))
                    .y(d => yScale(d.totalTokensUsed))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", "#00ff88")
                    .attr("stroke-width", 2)
                    .attr("d", line);

                // Tokens saved line
                const savedLine = d3.line()
                    .x(d => xScale(d.timestamp))
                    .y(d => yScale(d.totalTokensSaved))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", "#ffaa00")
                    .attr("stroke-width", 2)
                    .attr("d", savedLine);

                // Add gradient definition
                const defs = svg.append("defs");
                defs.append("linearGradient")
                    .attr("id", "gradient1")
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", 0).attr("y1", height - margin.bottom)
                    .attr("x2", 0).attr("y2", margin.top)
                    .selectAll("stop")
                    .data([
                        { offset: "0%", color: "rgba(0, 255, 136, 0.3)" },
                        { offset: "100%", color: "rgba(0, 255, 136, 0.05)" }
                    ])
                    .enter().append("stop")
                    .attr("offset", d => d.offset)
                    .attr("stop-color", d => d.color);

                // Legend
                const legend = g.append("g")
                    .attr("transform", `translate(${width - margin.right - 100}, ${margin.top})`);

                legend.append("line")
                    .attr("x1", 0).attr("x2", 20)
                    .attr("y1", 0).attr("y2", 0)
                    .attr("stroke", "#00ff88")
                    .attr("stroke-width", 2);

                legend.append("text")
                    .attr("x", 25).attr("y", 0)
                    .attr("dy", "0.35em")
                    .attr("fill", "#b0b0b0")
                    .text("Tokens Used");

                legend.append("line")
                    .attr("x1", 0).attr("x2", 20)
                    .attr("y1", 20).attr("y2", 20)
                    .attr("stroke", "#ffaa00")
                    .attr("stroke-width", 2);

                legend.append("text")
                    .attr("x", 25).attr("y", 20)
                    .attr("dy", "0.35em")
                    .attr("fill", "#b0b0b0")
                    .text("Tokens Saved");

            }, []);

            return <svg ref={svgRef} width="100%" height="400" style={{border: "1px solid #333"}}></svg>;
        };

        // Timeline View Component
        const TimelineView = () => {
            const svgRef = React.useRef(null);

            React.useEffect(() => {
                if (!svgRef.current) return;

                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                // Demo timeline data
                const events = [
                    { id: 1, name: "Data Collection", start: Date.now() - 3600000, duration: 900000, type: "data" },
                    { id: 2, name: "Processing", start: Date.now() - 2700000, duration: 1200000, type: "process" },
                    { id: 3, name: "Analysis", start: Date.now() - 1500000, duration: 600000, type: "analysis" },
                    { id: 4, name: "Validation", start: Date.now() - 900000, duration: 300000, type: "validation" },
                    { id: 5, name: "Reporting", start: Date.now() - 600000, duration: 300000, type: "report" }
                ];

                const width = 800;
                const height = 200;
                const margin = { top: 40, right: 20, bottom: 40, left: 100 };

                // Set up scales
                const xScale = d3.scaleTime()
                    .domain(d3.extent(events, d => d.start + d.duration))
                    .range([margin.left, width - margin.right]);

                const yScale = d3.scaleBand()
                    .domain(events.map(d => d.name))
                    .range([margin.top, height - margin.bottom])
                    .padding(0.1);

                // Create main group
                const g = svg.append("g");

                // Add axes
                g.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")));

                g.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(yScale));

                // Color scale for event types
                const colorScale = d3.scaleOrdinal()
                    .domain(["data", "process", "analysis", "validation", "report"])
                    .range(["#00ff88", "#ffaa00", "#4ecdc4", "#ff6b6b", "#9b59b6"]);

                // Draw timeline bars
                g.selectAll(".timeline-bar")
                    .data(events)
                    .enter()
                    .append("rect")
                    .attr("class", "timeline-bar")
                    .attr("x", d => xScale(d.start))
                    .attr("y", d => yScale(d.name))
                    .attr("width", d => xScale(d.start + d.duration) - xScale(d.start))
                    .attr("height", yScale.bandwidth())
                    .attr("fill", d => colorScale(d.type))
                    .attr("rx", 4)
                    .attr("ry", 4);

                // Add event labels
                g.selectAll(".event-label")
                    .data(events)
                    .enter()
                    .append("text")
                    .attr("class", "event-label")
                    .attr("x", d => xScale(d.start) + 5)
                    .attr("y", d => yScale(d.name) + yScale.bandwidth() / 2)
                    .attr("dy", "0.35em")
                    .attr("fill", "#ffffff")
                    .attr("font-size", "12px")
                    .text(d => d.name || 'Unknown');

            }, []);

            return <svg ref={svgRef} width="100%" height="200" style={{border: "1px solid #333"}}></svg>;
        };

        // Main App Component
        const App = () => {
            return (
                <div>
                    <WorkflowGraph />
                    <PerformanceChart />
                    <ValueDashboard />
                    <TimelineView />
                </div>
            );
        };

        // Render the app components to their respective containers
        console.log('Starting React component rendering...');

        const workflowContainer = document.getElementById('workflow-graph-container');
        const performanceContainer = document.getElementById('performance-chart-container');
        const valueContainer = document.getElementById('value-dashboard-container');
        const timelineContainer = document.getElementById('timeline-view-container');

        console.log('Containers found:', {
            workflow: !!workflowContainer,
            performance: !!performanceContainer,
            value: !!valueContainer,
            timeline: !!timelineContainer
        });

        if (workflowContainer) {
            console.log('Rendering WorkflowGraph...');
            const root = ReactDOM.createRoot(workflowContainer);
            root.render(<WorkflowGraph />);
        }
        if (performanceContainer) {
            console.log('Rendering PerformanceChart...');
            const root = ReactDOM.createRoot(performanceContainer);
            root.render(<PerformanceChart />);
        }
        if (valueContainer) {
            console.log('Rendering ValueDashboard...');
            const root = ReactDOM.createRoot(valueContainer);
            root.render(<ValueDashboard />);
        }
        if (timelineContainer) {
            console.log('Rendering TimelineView...');
            const root = ReactDOM.createRoot(timelineContainer);
            root.render(<TimelineView />);
        }

        console.log('React component rendering completed');
    </script>
</body>
</html>
